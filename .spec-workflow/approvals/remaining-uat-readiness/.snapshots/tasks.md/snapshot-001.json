{
  "id": "snapshot_1763071708416_qg7hs20xy",
  "approvalId": "approval_1763071708411_jl857angv",
  "approvalTitle": "Tasks Document - UAT Readiness Code Quality Remediation",
  "version": 1,
  "timestamp": "2025-11-13T22:08:28.416Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document: UAT Readiness - Code Quality Remediation\n\n## Phase 1: Critical Fixes (Week 1)\n\n### 1. Dependency Injection Setup\n\n- [ ] 1.1. Add get_it dependency to pubspec.yaml (Estimate: 0.5 hours, Priority: Critical)\n  - File: pubspec.yaml\n  - Add `get_it: ^8.0.0` to dependencies section\n  - Run `flutter pub get` to install dependency\n  - _Leverage: existing dependency management patterns in pubspec.yaml_\n  - _Requirements: US-2_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in dependency management | Task: Add get_it version 8.0.0 to pubspec.yaml dependencies section and run flutter pub get to install | Restrictions: Do not modify existing dependencies, maintain semantic versioning, do not add unnecessary dependencies | Success: get_it is installed successfully, flutter pub get completes without errors, dependency is available for import_\n\n- [ ] 1.2. Create DI service locator setup (Estimate: 2 hours, Priority: Critical)\n  - File: lib/di/service_locator.dart\n  - Create setupServiceLocator() function to register all services\n  - Implement resetServiceLocator() for testing\n  - Register AudioService, PermissionService, SettingsService, StorageService, DebugService as singletons\n  - _Leverage: existing service interfaces (IAudioService, IPermissionService, etc.)_\n  - _Requirements: US-2_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer specializing in dependency injection and service locator patterns | Task: Create service_locator.dart with setupServiceLocator() and resetServiceLocator() functions, registering all services as singletons using GetIt container following the design document | Restrictions: Must fail fast if services not registered, do not create circular dependencies, maintain proper service initialization order | Success: All services are registered correctly, setupServiceLocator() initializes async services, resetServiceLocator() properly disposes services for testing_\n\n### 2. Stream Implementation (FFI Layer)\n\n- [ ] 2.1. Implement classification stream FFI (Rust) (Estimate: 3 hours, Priority: Critical)\n  - File: rust/src/api.rs\n  - Add classification_stream() FFI method returning Stream<ClassificationResult>\n  - Implement subscribe_classification() in AppContext\n  - Use tokio broadcast channel with mpsc forwarding for Flutter consumption\n  - _Leverage: existing ClassificationResult model, tokio broadcast infrastructure_\n  - _Requirements: US-1_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with expertise in FFI and async streams | Task: Implement classification_stream() FFI method in rust/src/api.rs and subscribe_classification() in AppContext using tokio broadcast → mpsc forwarding pattern as specified in design document | Restrictions: Must maintain lock-free audio path, do not block audio callbacks, ensure proper stream cleanup on unsubscribe | Success: classification_stream() returns Stream<ClassificationResult>, stream emits results within 100ms of onset detection, no memory leaks on subscription/unsubscription_\n\n- [ ] 2.2. Implement classification stream FFI (Dart) (Estimate: 2 hours, Priority: Critical)\n  - File: lib/services/audio/audio_service_impl.dart\n  - Implement getClassificationStream() using StreamController.broadcast\n  - Subscribe to FFI stream and forward to StreamController\n  - Handle stream errors gracefully with AudioServiceException\n  - _Leverage: existing AudioServiceImpl, flutter_rust_bridge generated bindings_\n  - _Requirements: US-1_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in streams and reactive programming | Task: Implement getClassificationStream() in AudioServiceImpl using StreamController.broadcast pattern as specified in design, subscribing to FFI stream and handling errors | Restrictions: Must use lazy initialization, properly handle stream cancellation, emit error states rather than throwing exceptions | Success: Stream emits ClassificationResult objects, handles errors gracefully, multiple subscribers supported via broadcast, stream cleanup on cancel_\n\n- [ ] 2.3. Implement calibration stream FFI (Rust) (Estimate: 3 hours, Priority: Critical)\n  - File: rust/src/api.rs\n  - Add calibration_stream() FFI method returning Stream<CalibrationProgress>\n  - Implement subscribe_calibration() in AppContext\n  - Use tokio broadcast channel with mpsc forwarding for Flutter consumption\n  - _Leverage: existing CalibrationProgress model, tokio broadcast infrastructure_\n  - _Requirements: US-1_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with expertise in FFI and async streams | Task: Implement calibration_stream() FFI method in rust/src/api.rs and subscribe_calibration() in AppContext using tokio broadcast → mpsc forwarding pattern as specified in design document | Restrictions: Must maintain lock-free audio path, do not block calibration callbacks, ensure proper stream cleanup on unsubscribe | Success: calibration_stream() returns Stream<CalibrationProgress>, stream emits progress updates for each sample collection, no memory leaks on subscription/unsubscription_\n\n- [ ] 2.4. Implement calibration stream FFI (Dart) (Estimate: 2 hours, Priority: Critical)\n  - File: lib/services/audio/audio_service_impl.dart\n  - Implement getCalibrationStream() using StreamController.broadcast\n  - Subscribe to FFI stream and forward to StreamController\n  - Handle stream errors gracefully with CalibrationServiceException\n  - _Leverage: existing AudioServiceImpl, flutter_rust_bridge generated bindings_\n  - _Requirements: US-1_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in streams and reactive programming | Task: Implement getCalibrationStream() in AudioServiceImpl using StreamController.broadcast pattern as specified in design, subscribing to FFI stream and handling errors | Restrictions: Must use lazy initialization, properly handle stream cancellation, emit error states rather than throwing exceptions | Success: Stream emits CalibrationProgress objects, handles errors gracefully, multiple subscribers supported via broadcast, stream cleanup on cancel_\n\n### 3. Widget Testability (Remove Default Instantiation)\n\n- [ ] 3.1. Create INavigationService interface (Estimate: 1 hour, Priority: Critical)\n  - File: lib/services/navigation/i_navigation_service.dart\n  - Define abstract interface with goTo(), goBack(), replace(), canGoBack() methods\n  - Document interface purpose and usage\n  - _Leverage: existing service interface patterns (IAudioService, etc.)_\n  - _Requirements: US-4, US-9_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Architect specializing in abstraction and interface design | Task: Create INavigationService interface with goTo(), goBack(), replace(), canGoBack() methods as specified in design document | Restrictions: Must be framework-agnostic, do not expose go_router implementation details, maintain simple clear contract | Success: Interface is well-defined with dartdoc comments, methods have clear signatures, interface supports all navigation use cases_\n\n- [ ] 3.2. Implement GoRouterNavigationService (Estimate: 1.5 hours, Priority: Critical)\n  - File: lib/services/navigation/go_router_navigation_service.dart\n  - Implement INavigationService using GoRouter\n  - Wrap go_router methods (go, pop, replace, canPop)\n  - _Leverage: existing go_router configuration, INavigationService interface_\n  - _Requirements: US-4, US-9_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in navigation and routing | Task: Implement GoRouterNavigationService that wraps GoRouter methods implementing INavigationService as specified in design document | Restrictions: Must only wrap go_router, do not add business logic, ensure thread-safe navigation calls | Success: All INavigationService methods are implemented correctly, navigation works identically to direct go_router usage, no regressions in navigation behavior_\n\n- [ ] 3.3. Refactor TrainingScreen constructor (Estimate: 2 hours, Priority: Critical)\n  - File: lib/ui/screens/training_screen.dart\n  - Remove default service instantiation from constructor parameters\n  - Create factory constructor .create() that resolves services from GetIt\n  - Create test constructor .test() accepting mock services\n  - Make all service dependencies required non-nullable parameters\n  - _Leverage: existing TrainingScreen implementation, service locator_\n  - _Requirements: US-3_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in widget architecture and dependency injection | Task: Refactor TrainingScreen to remove default instantiation, add .create() factory using GetIt and .test() factory for testing as specified in design document | Restrictions: Do not break existing functionality, must use private constructor, ensure all dependencies are required and non-nullable | Success: Widget has no default instantiation, .create() factory works in production, .test() factory enables widget testing with mocks, all tests pass_\n\n- [ ] 3.4. Refactor CalibrationScreen constructor (Estimate: 2 hours, Priority: Critical)\n  - File: lib/ui/screens/calibration_screen.dart\n  - Remove default service instantiation from constructor parameters\n  - Create factory constructor .create() that resolves services from GetIt\n  - Create test constructor .test() accepting mock services\n  - Make all service dependencies required non-nullable parameters\n  - _Leverage: existing CalibrationScreen implementation, service locator_\n  - _Requirements: US-3_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in widget architecture and dependency injection | Task: Refactor CalibrationScreen to remove default instantiation, add .create() factory using GetIt and .test() factory for testing as specified in design document | Restrictions: Do not break existing functionality, must use private constructor, ensure all dependencies are required and non-nullable | Success: Widget has no default instantiation, .create() factory works in production, .test() factory enables widget testing with mocks, all tests pass_\n\n- [ ] 3.5. Refactor SettingsScreen constructor (Estimate: 1.5 hours, Priority: Critical)\n  - File: lib/ui/screens/settings_screen.dart\n  - Remove default service instantiation from constructor parameters\n  - Create factory constructor .create() that resolves services from GetIt\n  - Create test constructor .test() accepting mock services\n  - Make all service dependencies required non-nullable parameters\n  - _Leverage: existing SettingsScreen implementation, service locator_\n  - _Requirements: US-3_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in widget architecture and dependency injection | Task: Refactor SettingsScreen to remove default instantiation, add .create() factory using GetIt and .test() factory for testing as specified in design document | Restrictions: Do not break existing functionality, must use private constructor, ensure all dependencies are required and non-nullable | Success: Widget has no default instantiation, .create() factory works in production, .test() factory enables widget testing with mocks, all tests pass_\n\n- [ ] 3.6. Update main.dart router configuration (Estimate: 1 hour, Priority: Critical)\n  - File: lib/main.dart\n  - Update GoRouter routes to use .create() factory constructors\n  - Call setupServiceLocator() before runApp()\n  - Register NavigationService with router instance\n  - _Leverage: service locator, refactored screen widgets_\n  - _Requirements: US-2, US-3, US-4_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in app initialization and routing | Task: Update main.dart to call setupServiceLocator() before runApp() and update GoRouter to use .create() factory constructors as specified in design document | Restrictions: Must maintain proper initialization order, do not skip service registration, ensure router is configured before app starts | Success: App initializes correctly with DI container, all routes use factory constructors, navigation works correctly, no initialization errors_\n\n### 4. Testing Phase 1 Implementation\n\n- [ ] 4.1. Write unit tests for stream implementations (Estimate: 3 hours, Priority: Critical)\n  - File: test/services/audio/audio_service_impl_test.dart\n  - Test getClassificationStream() emits results correctly\n  - Test getCalibrationStream() emits progress correctly\n  - Test stream error handling\n  - Test stream cleanup on cancellation\n  - _Leverage: existing test utilities, mock FFI bridge_\n  - _Requirements: US-1_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with expertise in Flutter testing and stream testing | Task: Write comprehensive unit tests for getClassificationStream() and getCalibrationStream() covering success, error, and cleanup scenarios | Restrictions: Must mock FFI layer, test stream behavior in isolation, ensure tests are deterministic and fast | Success: All stream methods are tested, error scenarios covered, tests pass reliably, stream cleanup verified_\n\n- [ ] 4.2. Write unit tests for DI setup (Estimate: 2 hours, Priority: Critical)\n  - File: test/di/service_locator_test.dart\n  - Test setupServiceLocator() registers all services\n  - Test service resolution works correctly\n  - Test resetServiceLocator() cleans up properly\n  - Test fail-fast behavior for missing services\n  - _Leverage: existing test utilities_\n  - _Requirements: US-2_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with expertise in dependency injection testing | Task: Write comprehensive unit tests for service_locator.dart covering service registration, resolution, and cleanup scenarios | Restrictions: Must test in isolation, verify singleton behavior, ensure proper cleanup for test isolation | Success: All DI functionality is tested, service registration verified, cleanup works correctly, tests are isolated_\n\n- [ ] 4.3. Write integration tests for stream workflows (Estimate: 3 hours, Priority: Critical)\n  - File: test/integration/stream_workflows_test.dart\n  - Test end-to-end classification stream from Rust to Dart\n  - Test end-to-end calibration stream from Rust to Dart\n  - Test audio engine start → classification stream → results emission\n  - _Leverage: existing integration test infrastructure_\n  - _Requirements: US-1_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Integration Test Engineer with expertise in end-to-end testing | Task: Write integration tests verifying stream functionality from Rust through FFI to Dart UI as specified in design document | Restrictions: Must test real integration points, use minimal mocking, ensure tests run on CI/CD pipeline | Success: End-to-end stream workflows verified, classification and calibration streams tested, tests run reliably in CI_\n\n## Phase 2: High Priority Refactoring (Weeks 2-3)\n\n### 5. Rust AppContext Refactoring\n\n- [ ] 5.1. Create AudioEngineManager (Estimate: 4 hours, Priority: High)\n  - File: rust/src/managers/audio_engine_manager.rs\n  - Extract audio engine lifecycle methods from AppContext\n  - Implement start(), stop(), set_bpm() with validation\n  - Reduce method complexity from 86 lines to < 50 lines per method\n  - _Leverage: existing AppContext audio methods, AudioEngine, BufferPool_\n  - _Requirements: US-5, US-8_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer specializing in refactoring and SOLID principles | Task: Extract AudioEngineManager from AppContext implementing start(), stop(), set_bpm() methods with Single Responsibility Principle and methods under 50 lines as specified in design document | Restrictions: Must maintain lock-free audio path, do not introduce performance regression, ensure thread safety with Arc/Mutex | Success: AudioEngineManager compiles and works correctly, all methods under 50 lines, maintains existing audio performance, proper error handling_\n\n- [ ] 5.2. Create CalibrationManager (Estimate: 3 hours, Priority: High)\n  - File: rust/src/managers/calibration_manager.rs\n  - Extract calibration workflow methods from AppContext\n  - Implement start(), finish(), get_state(), load_state()\n  - Manage calibration procedure and state persistence\n  - _Leverage: existing AppContext calibration methods, CalibrationProcedure, CalibrationState_\n  - _Requirements: US-5_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer specializing in state management and refactoring | Task: Extract CalibrationManager from AppContext implementing calibration workflow and state management as specified in design document | Restrictions: Must maintain thread safety, do not lose calibration data, ensure proper state transitions | Success: CalibrationManager compiles and works correctly, calibration workflow preserved, state management robust, proper error handling_\n\n- [ ] 5.3. Create BroadcastChannelManager (Estimate: 3 hours, Priority: High)\n  - File: rust/src/managers/broadcast_manager.rs\n  - Extract broadcast channel setup from AppContext\n  - Implement init_classification(), subscribe_classification(), init_calibration(), subscribe_calibration()\n  - Centralize all tokio broadcast channel management\n  - _Leverage: existing AppContext broadcast channel code, tokio::sync::broadcast_\n  - _Requirements: US-5_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with expertise in async channels and concurrency | Task: Extract BroadcastChannelManager from AppContext centralizing tokio broadcast channel management as specified in design document | Restrictions: Must maintain thread safety, ensure proper channel cleanup, support multiple subscribers | Success: BroadcastChannelManager compiles and works correctly, all channels managed centrally, subscription/unsubscription works properly_\n\n- [ ] 5.4. Refactor AppContext to facade pattern (Estimate: 3 hours, Priority: High)\n  - File: rust/src/context.rs\n  - Compose AudioEngineManager, CalibrationManager, BroadcastChannelManager\n  - Delegate all methods to respective managers\n  - Reduce file size from 1392 lines to < 200 lines\n  - _Leverage: AudioEngineManager, CalibrationManager, BroadcastChannelManager_\n  - _Requirements: US-5_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Architect specializing in facade pattern and composition | Task: Refactor AppContext to facade pattern delegating to managers, reducing file to under 200 lines as specified in design document | Restrictions: Must maintain existing public API, ensure zero performance regression, preserve all functionality | Success: AppContext is under 200 lines, delegates to managers correctly, all existing functionality preserved, no breaking changes to public API_\n\n- [ ] 5.5. Create module exports for managers (Estimate: 0.5 hours, Priority: High)\n  - File: rust/src/managers/mod.rs\n  - Export AudioEngineManager, CalibrationManager, BroadcastChannelManager\n  - Document manager responsibilities\n  - _Leverage: managers created in previous tasks_\n  - _Requirements: US-5_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with module organization expertise | Task: Create managers/mod.rs exporting all manager modules with proper documentation | Restrictions: Follow Rust module conventions, maintain clear public API | Success: All managers are properly exported, module compiles, documentation is clear_\n\n### 6. Dart Business Logic Extraction\n\n- [ ] 6.1. Create TrainingController (Estimate: 4 hours, Priority: High)\n  - File: lib/controllers/training/training_controller.dart\n  - Extract business logic from TrainingScreen\n  - Implement startTraining(), stopTraining(), updateBpm()\n  - Handle permission requests, BPM validation, audio lifecycle\n  - _Leverage: IAudioService, IPermissionService, ISettingsService_\n  - _Requirements: US-6_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer specializing in controller pattern and business logic separation | Task: Create TrainingController extracting business logic from TrainingScreen implementing audio lifecycle, BPM management, and permissions as specified in design document | Restrictions: Must not contain UI code, properly handle async operations, maintain clear separation from view layer | Success: Controller handles all business logic, methods are testable independently, audio lifecycle managed correctly, BPM validation works_\n\n- [ ] 6.2. Refactor TrainingScreen to UI-only (Estimate: 3 hours, Priority: High)\n  - File: lib/ui/screens/training_screen.dart\n  - Remove business logic, keep only UI rendering\n  - Inject TrainingController via constructor\n  - Reduce file size from 614 lines to < 500 lines\n  - _Leverage: TrainingController, existing UI components_\n  - _Requirements: US-6_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter UI Developer specializing in clean view layer architecture | Task: Refactor TrainingScreen to UI-only delegating business logic to TrainingController, reducing file to under 500 lines as specified in design document | Restrictions: Must maintain existing UI functionality, only render UI, delegate all business logic to controller | Success: TrainingScreen is under 500 lines, contains only UI code, delegates to controller correctly, UI functionality preserved_\n\n- [ ] 6.3. Wire TrainingController to UI (Estimate: 1 hour, Priority: High)\n  - File: lib/ui/screens/training_screen.dart\n  - Update factory constructors to create TrainingController\n  - Connect UI events to controller methods\n  - Subscribe to controller streams for state updates\n  - _Leverage: TrainingController, service locator_\n  - _Requirements: US-6_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in MVC architecture | Task: Wire TrainingController to TrainingScreen UI connecting events and state as specified in design document | Restrictions: Must maintain reactive UI updates, properly dispose controller, handle async operations correctly | Success: UI responds to controller state changes, events trigger controller methods, controller lifecycle managed properly_\n\n### 7. Error Code Consolidation\n\n- [ ] 7.1. Create error_codes.rs module (Estimate: 2 hours, Priority: High)\n  - File: rust/src/error.rs\n  - Define AudioErrorCodes and CalibrationErrorCodes structs with const values\n  - Add #[frb] annotations for FFI exposure\n  - Implement code() method on error enums to return constants\n  - _Leverage: existing AudioError and CalibrationError enums_\n  - _Requirements: US-7_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with expertise in error handling and FFI | Task: Create error code constants in error.rs with FFI annotations exposing to Dart as specified in design document | Restrictions: Must maintain existing error enum functionality, ensure constants are FFI-compatible, follow naming conventions | Success: Error codes defined as constants, FFI annotations correct, code() method returns proper constants, no breaking changes_\n\n- [ ] 7.2. Expose error codes via FFI (Estimate: 1 hour, Priority: High)\n  - File: rust/src/error.rs\n  - Run flutter_rust_bridge codegen to generate Dart constants\n  - Verify generated AudioErrorCodes and CalibrationErrorCodes classes in Dart\n  - _Leverage: flutter_rust_bridge, error code definitions_\n  - _Requirements: US-7_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust/Dart Bridge Engineer with FFI expertise | Task: Run flutter_rust_bridge codegen and verify Dart error code constants are generated correctly | Restrictions: Do not manually write Dart constants, rely on codegen, verify all constants match Rust definitions | Success: Codegen completes successfully, Dart constants available, all error codes accessible from Dart_\n\n- [ ] 7.3. Update Dart error handling (Estimate: 2 hours, Priority: High)\n  - File: lib/services/error_handler/error_handler.dart\n  - Replace magic number error codes with AudioErrorCodes.* constants\n  - Update all error translation switch statements\n  - Remove hardcoded numeric error codes\n  - _Leverage: generated AudioErrorCodes, CalibrationErrorCodes_\n  - _Requirements: US-7_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with expertise in error handling and refactoring | Task: Update error handler to use FFI-exposed error code constants replacing all magic numbers as specified in design document | Restrictions: Must maintain existing error handling behavior, ensure all error codes covered, do not skip any translation cases | Success: No magic numbers in error handling, all switch cases use named constants, error translation works correctly_\n\n### 8. Large Function Refactoring\n\n- [ ] 8.1. Refactor large functions in TrainingScreen (Estimate: 2 hours, Priority: High)\n  - File: lib/ui/screens/training_screen.dart\n  - Extract helper methods from any function > 50 lines\n  - Apply Single Level of Abstraction Principle (SLAP)\n  - Ensure all functions under 50 lines\n  - _Leverage: existing TrainingScreen code_\n  - _Requirements: US-8_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer specializing in clean code and refactoring | Task: Refactor all functions over 50 lines in TrainingScreen extracting helpers following SLAP principle as specified in design document | Restrictions: Must maintain existing functionality, each function single abstraction level, do not introduce unnecessary complexity | Success: All functions under 50 lines, code more readable, SLAP applied correctly, no functional regressions_\n\n- [ ] 8.2. Refactor large functions in CalibrationScreen (Estimate: 2 hours, Priority: High)\n  - File: lib/ui/screens/calibration_screen.dart\n  - Extract _retrieveCalibrationData() from _finishCalibration()\n  - Extract _handleSuccessfulCalibration() helper method\n  - Extract _handleCalibrationError() helper method\n  - Ensure all functions under 50 lines\n  - _Leverage: existing CalibrationScreen code, INavigationService_\n  - _Requirements: US-8_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer specializing in clean code and refactoring | Task: Refactor _finishCalibration() and other large functions in CalibrationScreen extracting helpers following SLAP as specified in design document | Restrictions: Must maintain existing functionality, each function single abstraction level, use navigation service abstraction | Success: All functions under 50 lines, _finishCalibration() simplified to high-level steps, code more readable, no functional regressions_\n\n- [ ] 8.3. Refactor large functions in Rust managers (Estimate: 2 hours, Priority: High)\n  - File: rust/src/managers/*.rs\n  - Extract validation, setup, and cleanup helpers from manager methods\n  - Ensure all manager methods under 50 lines\n  - Apply SLAP to all extracted methods\n  - _Leverage: manager code from Phase 2 tasks 5.1-5.3_\n  - _Requirements: US-8_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer specializing in clean code and refactoring | Task: Refactor any manager methods over 50 lines extracting helper methods following SLAP as specified in design document | Restrictions: Must maintain thread safety, each function single abstraction level, do not introduce performance overhead | Success: All manager methods under 50 lines, code more readable, SLAP applied correctly, no performance or functional regressions_\n\n### 9. Interface Segregation\n\n- [ ] 9.1. Split IDebugService interface (Estimate: 2 hours, Priority: High)\n  - File: lib/services/debug/i_audio_metrics_provider.dart, lib/services/debug/i_onset_event_provider.dart, lib/services/debug/i_log_exporter.dart\n  - Create IAudioMetricsProvider with getAudioMetricsStream()\n  - Create IOnsetEventProvider with getOnsetEventsStream()\n  - Create ILogExporter with exportLogs()\n  - _Leverage: existing IDebugService interface_\n  - _Requirements: US-10_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Architect specializing in Interface Segregation Principle | Task: Split IDebugService into three focused interfaces (IAudioMetricsProvider, IOnsetEventProvider, ILogExporter) as specified in design document | Restrictions: Must follow ISP, each interface single responsibility, maintain clear contracts | Success: Three focused interfaces created, each with single responsibility, well-documented with dartdoc_\n\n- [ ] 9.2. Update DebugServiceImpl to implement split interfaces (Estimate: 1.5 hours, Priority: High)\n  - File: lib/services/debug/debug_service_impl.dart\n  - Update class to implement IAudioMetricsProvider, IOnsetEventProvider, ILogExporter\n  - Ensure all interface methods implemented correctly\n  - _Leverage: existing DebugServiceImpl, split interfaces_\n  - _Requirements: US-10_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter Developer with interface implementation expertise | Task: Update DebugServiceImpl to implement all three focused interfaces as specified in design document | Restrictions: Must implement all methods, maintain existing functionality, ensure composition pattern works | Success: DebugServiceImpl implements all three interfaces, all methods work correctly, no functional regressions_\n\n- [ ] 9.3. Update DI registration for split interfaces (Estimate: 1 hour, Priority: High)\n  - File: lib/di/service_locator.dart\n  - Register DebugServiceImpl as all three interface types\n  - Enable independent resolution of each interface\n  - _Leverage: service locator, DebugServiceImpl, split interfaces_\n  - _Requirements: US-10_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter DI specialist with GetIt expertise | Task: Update service_locator.dart to register DebugServiceImpl as all three focused interfaces enabling independent resolution as specified in design document | Restrictions: Must use same instance for all interfaces, ensure proper resolution, maintain singleton pattern | Success: All three interfaces resolvable independently, same instance returned, DI configuration correct_\n\n### 10. Stream Simplification\n\n- [ ] 10.1. Simplify Rust stream plumbing (Estimate: 3 hours, Priority: High)\n  - File: rust/src/audio/engine.rs, rust/src/managers/broadcast_manager.rs\n  - Refactor audio engine to send directly to broadcast channel\n  - Remove mpsc → broadcast forwarding layer\n  - Eliminate unnecessary tokio::spawn forwarding tasks\n  - _Leverage: BroadcastChannelManager, AudioEngine_\n  - _Requirements: US-11_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust async expert specializing in channel patterns and performance | Task: Simplify stream plumbing by having audio engine send directly to broadcast channel eliminating mpsc forwarding as specified in design document | Restrictions: Must maintain lock-free audio path, do not introduce performance regression, ensure fan-out still works | Success: Audio engine sends directly to broadcast, mpsc forwarding removed, fewer lines of stream setup code, same or better performance_\n\n### 11. Platform Stubs for Testing\n\n- [ ] 11.1. Create platform stubs for desktop testing (Estimate: 3 hours, Priority: High)\n  - File: rust/src/audio/stubs.rs\n  - Create StubAudioEngine with basic state (bpm, is_running)\n  - Implement start(), stop(), set_bpm() stub methods\n  - Add conditional compilation #[cfg(not(target_os = \"android\"))]\n  - _Leverage: existing AudioEngine interface_\n  - _Requirements: US-12_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust Developer with cross-platform and testing expertise | Task: Create StubAudioEngine for desktop testing with conditional compilation as specified in design document | Restrictions: Only compile on non-Android platforms, maintain same interface as real engine, no actual audio processing | Success: StubAudioEngine compiles on desktop platforms, implements required methods, cargo test runs on desktop without Android emulator_\n\n- [ ] 11.2. Add platform abstraction layer (Estimate: 2 hours, Priority: High)\n  - File: rust/src/audio/engine.rs\n  - Add type alias: PlatformAudioEngine = OboeAudioEngine (Android) or StubAudioEngine (desktop)\n  - Update AudioEngine to use PlatformAudioEngine\n  - Ensure conditional compilation works correctly\n  - _Leverage: StubAudioEngine, existing OboeAudioEngine_\n  - _Requirements: US-12_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust platform engineer with conditional compilation expertise | Task: Add platform abstraction using type aliases for Android vs desktop as specified in design document | Restrictions: Must compile correctly on all platforms, no runtime overhead, maintain type safety | Success: Code compiles on Android with OboeAudioEngine, compiles on desktop with StubAudioEngine, no performance impact_\n\n### 12. Testing Phase 2 Implementation\n\n- [ ] 12.1. Write unit tests for Rust managers (Estimate: 4 hours, Priority: High)\n  - File: rust/src/managers/audio_engine_manager.rs, rust/src/managers/calibration_manager.rs, rust/src/managers/broadcast_manager.rs (tests module)\n  - Test AudioEngineManager start/stop/setBpm with stub engine\n  - Test CalibrationManager state transitions\n  - Test BroadcastChannelManager subscription handling\n  - _Leverage: platform stubs, Rust test framework_\n  - _Requirements: US-5_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Rust QA Engineer with unit testing expertise | Task: Write comprehensive unit tests for all three managers covering success, error, and edge cases running on desktop | Restrictions: Must use stub engine, tests must run on desktop, ensure proper test isolation | Success: All manager methods tested, tests run on desktop with cargo test, 90%+ coverage for managers, tests are reliable_\n\n- [ ] 12.2. Write unit tests for TrainingController (Estimate: 3 hours, Priority: High)\n  - File: test/controllers/training/training_controller_test.dart\n  - Test startTraining() with permission handling\n  - Test stopTraining() lifecycle\n  - Test updateBpm() validation and service calls\n  - Test error scenarios\n  - _Leverage: mock services, Flutter test framework_\n  - _Requirements: US-6_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter QA Engineer with controller testing expertise | Task: Write comprehensive unit tests for TrainingController covering all business logic scenarios with mocked services | Restrictions: Must mock all service dependencies, test business logic in isolation, ensure deterministic tests | Success: All controller methods tested, permission flows verified, BPM validation tested, error handling covered, 90%+ coverage_\n\n- [ ] 12.3. Write integration tests for refactored code (Estimate: 4 hours, Priority: High)\n  - File: test/integration/refactored_workflows_test.dart\n  - Test end-to-end training workflow with TrainingController\n  - Test AppContext facade delegates to managers correctly\n  - Test navigation service integration\n  - _Leverage: integration test infrastructure, real services_\n  - _Requirements: All Phase 2 requirements_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Integration Test Engineer with end-to-end testing expertise | Task: Write integration tests verifying refactored architecture works end-to-end including managers, controllers, and navigation | Restrictions: Use real services where possible, minimal mocking, ensure tests run on CI/CD | Success: End-to-end workflows verified, refactored code works correctly integrated, tests run reliably in CI_\n\n- [ ] 12.4. Update widget tests for refactored screens (Estimate: 3 hours, Priority: High)\n  - File: test/ui/screens/training_screen_test.dart, test/ui/screens/calibration_screen_test.dart, test/ui/screens/settings_screen_test.dart\n  - Update tests to use .test() factory constructors\n  - Test UI renders correctly with mocked controller\n  - Test UI events trigger controller methods\n  - _Leverage: refactored screen widgets, mock controllers_\n  - _Requirements: US-3, US-6_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Flutter QA Engineer with widget testing expertise | Task: Update widget tests for refactored screens using .test() factory constructors and mocked controllers/services | Restrictions: Must use test factories, mock all dependencies, test UI behavior only | Success: All screen widget tests updated and passing, UI tested in isolation, controller/service interactions verified via mocks_\n\n## Phase 3: Code Quality & Documentation\n\n### 13. Code Quality Verification\n\n- [ ] 13.1. Run static analysis and fix warnings (Estimate: 2 hours, Priority: Medium)\n  - File: various\n  - Run `dart analyze` and fix all warnings\n  - Run `cargo clippy` and fix all warnings\n  - Ensure zero linting errors\n  - _Leverage: dart analyzer, cargo clippy_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Code Quality Engineer with linting expertise | Task: Run static analysis tools (dart analyze, cargo clippy) and fix all warnings ensuring zero linting errors | Restrictions: Must fix warnings not suppress them, maintain code quality standards, do not introduce new issues | Success: dart analyze passes with zero warnings, cargo clippy passes with zero warnings, code quality improved_\n\n- [ ] 13.2. Verify code metrics compliance (Estimate: 2 hours, Priority: Medium)\n  - File: various\n  - Verify all files under 500 lines (excluding comments/blanks)\n  - Verify all functions under 50 lines (excluding comments/blanks)\n  - Generate metrics report\n  - _Leverage: code counting tools, custom scripts_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Code Quality Engineer with metrics analysis expertise | Task: Verify all files under 500 lines and all functions under 50 lines generating compliance report | Restrictions: Count only code lines excluding comments and blanks, identify violations, do not suppress metrics | Success: All files under 500 lines, all functions under 50 lines, compliance report generated, violations documented if any_\n\n- [ ] 13.3. Run test coverage report (Estimate: 1 hour, Priority: Medium)\n  - File: coverage reports\n  - Run `flutter test --coverage` for Dart code\n  - Run `cargo tarpaulin` or similar for Rust code\n  - Verify minimum 80% coverage (90% for critical paths)\n  - _Leverage: Flutter coverage tools, Rust coverage tools_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with code coverage expertise | Task: Generate test coverage reports for Dart and Rust code verifying minimum 80% coverage (90% for critical paths) | Restrictions: Must cover business logic thoroughly, identify coverage gaps, do not write tests just for coverage | Success: Coverage reports generated, minimum 80% overall coverage achieved, critical paths at 90%+ coverage, gaps identified_\n\n### 14. Documentation\n\n- [ ] 14.1. Document new architecture patterns (Estimate: 2 hours, Priority: Medium)\n  - File: docs/architecture/dependency_injection.md, docs/architecture/managers.md, docs/architecture/controllers.md\n  - Document DI setup and usage patterns\n  - Document manager pattern in Rust\n  - Document controller pattern in Flutter\n  - _Leverage: implemented code, architecture decisions_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer with software architecture expertise | Task: Create architecture documentation covering DI setup, manager pattern, and controller pattern with examples | Restrictions: Must be accurate and reflect actual implementation, include code examples, maintain consistency with existing docs | Success: Architecture patterns documented clearly, examples provided, documentation is accurate and helpful_\n\n- [ ] 14.2. Update API documentation (Estimate: 2 hours, Priority: Medium)\n  - File: various Dart and Rust files\n  - Add/update dartdoc comments for all public APIs\n  - Add/update rustdoc comments for all public APIs\n  - Ensure all managers, controllers, and services documented\n  - _Leverage: existing code, dartdoc/rustdoc conventions_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer with API documentation expertise | Task: Add comprehensive dartdoc and rustdoc comments to all public APIs including managers, controllers, and services | Restrictions: Must document purpose, parameters, return values, and examples where helpful, follow doc conventions | Success: All public APIs documented, dartdoc/rustdoc generate complete documentation, documentation is clear and accurate_\n\n### 15. Final Integration & Validation\n\n- [ ] 15.1. Perform end-to-end manual testing (Estimate: 3 hours, Priority: Critical)\n  - File: N/A (manual testing)\n  - Test complete user workflows (onboarding → calibration → training)\n  - Verify all screens function correctly\n  - Test error handling and edge cases\n  - _Leverage: complete application, UAT scenarios_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Tester with manual testing expertise | Task: Perform comprehensive manual end-to-end testing of all user workflows verifying functionality, error handling, and user experience | Restrictions: Test on real Android device, follow UAT scenarios, document any issues found | Success: All user workflows work correctly, no critical bugs found, error handling works gracefully, application is production-ready_\n\n- [ ] 15.2. Performance validation (Estimate: 2 hours, Priority: Critical)\n  - File: N/A (performance testing)\n  - Verify < 20ms latency maintained\n  - Verify 0 jitter metronome maintained\n  - Verify < 15% CPU usage maintained\n  - Measure stream overhead (target < 5ms)\n  - _Leverage: performance monitoring tools, existing benchmarks_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Performance Engineer with profiling expertise | Task: Validate performance requirements are met including latency, jitter, CPU usage, and stream overhead | Restrictions: Must use real measurements, test on target hardware, do not rely on assumptions | Success: < 20ms latency verified, 0 jitter metronome verified, < 15% CPU usage verified, stream overhead < 5ms, no performance regressions_\n\n- [ ] 15.3. Create release checklist (Estimate: 1 hour, Priority: High)\n  - File: docs/release/uat_release_checklist.md\n  - Document all validation steps completed\n  - List known issues/limitations if any\n  - Document deployment instructions\n  - _Leverage: completed tasks, testing results_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec remaining-uat-readiness, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Release Manager with deployment expertise | Task: Create comprehensive UAT release checklist documenting validation, known issues, and deployment instructions | Restrictions: Must be accurate and complete, include all critical checks, document any known limitations | Success: Release checklist is comprehensive, all validation documented, deployment instructions clear, ready for UAT release_\n",
  "fileStats": {
    "size": 47584,
    "lines": 462,
    "lastModified": "2025-11-13T22:08:22.793Z"
  },
  "comments": []
}