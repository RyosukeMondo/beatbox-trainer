{
  "id": "snapshot_1762988691993_0624adnpk",
  "approvalId": "approval_1762988598165_leb6vwzwl",
  "approvalTitle": "Requirements: Code Quality Refactoring",
  "version": 2,
  "timestamp": "2025-11-12T23:04:51.993Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document: Code Quality Refactoring\n\n## Introduction\n\nThis specification addresses critical code quality, architectural, and testability issues identified in the comprehensive code audit conducted on 2025-11-13. The current codebase violates multiple SOLID principles, contains testability blockers (global state, hard dependencies), lacks error handling infrastructure, and has significant code duplication. This refactoring will establish a maintainable, testable architecture that aligns with professional development standards while preserving the real-time audio performance guarantees that are core to the product.\n\n**Value Proposition**: Reducing technical debt, enabling comprehensive test coverage (target: 80%), preventing production crashes (eliminating panic risks), and accelerating future feature development through clean architecture patterns.\n\n## Alignment with Product Vision\n\nThis refactoring directly supports the product principles outlined in product.md:\n\n1. **Uncompromising Real-Time Performance**: Refactoring will maintain zero-allocation audio path while making non-audio code testable through dependency injection\n2. **Transparency Over Black Boxes**: Custom error types with error codes make system behavior more interpretable and debuggable\n3. **Native-First Architecture**: Enhancing the Rust FFI layer with proper abstractions while preserving low-latency guarantees\n4. **Progressive Complexity**: Establishing modular architecture enables easier feature additions without increasing coupling\n\nThe refactoring enables reliable scaling as the product grows from 3 sound categories to 8+ categories and eventually user-defined sounds.\n\n## Requirements\n\n### Requirement 1: Eliminate Global State Testability Blockers\n\n**User Story**: As a developer, I want to unit test Rust backend components in isolation, so that I can verify correctness without side effects and run tests in parallel.\n\n#### Acceptance Criteria\n\n1. WHEN rust backend modules are tested THEN the system SHALL NOT depend on global static variables for core business logic\n2. WHEN multiple tests execute in parallel THEN the system SHALL NOT experience race conditions or shared state contamination\n3. WHEN testing audio engine lifecycle THEN the system SHALL support dependency injection for mocks and stubs\n4. IF a test requires audio engine state THEN the system SHALL provide an injectable `AudioContext` struct instead of global statics\n5. WHEN tests complete THEN the system SHALL properly cleanup resources without requiring process restart\n\n**Current Violations**:\n- `rust/src/api.rs` lines 25-43: 5 global `Lazy<Arc<Mutex<...>>>` variables\n- Cannot mock or stub dependencies\n- Tests cannot run in parallel safely\n- No way to inject test doubles\n\n### Requirement 2: Implement Comprehensive Error Handling Infrastructure\n\n**User Story**: As a developer, I want structured error types with error codes, so that I can handle failures appropriately and users receive meaningful feedback.\n\n#### Acceptance Criteria\n\n1. WHEN an error occurs in Rust code THEN the system SHALL return a custom error enum instead of `Result<T, String>`\n2. WHEN errors are propagated across FFI boundary THEN the system SHALL include error codes and context information\n3. WHEN errors reach the UI layer THEN the system SHALL translate technical errors to user-friendly messages\n4. IF a lock is poisoned or panic occurs THEN the system SHALL recover gracefully instead of crashing\n5. WHEN errors are logged THEN the system SHALL use structured JSON format with timestamp, level, service name, and context fields\n6. WHEN validation fails THEN the system SHALL provide specific error details (e.g., \"BPM 300 exceeds maximum 240\" vs \"Invalid BPM\")\n\n**Current Violations**:\n- All Rust functions return `Result<T, String>`\n- 11+ `.unwrap()` calls that can panic\n- Raw technical errors shown to users\n- No error codes or hierarchy\n\n### Requirement 3: Enforce Dependency Injection Pattern\n\n**User Story**: As a developer, I want all external dependencies injected through constructors, so that I can swap implementations for testing and maintain loose coupling.\n\n#### Acceptance Criteria\n\n1. WHEN Dart screens are created THEN the system SHALL inject audio service abstractions instead of directly importing `api.dart`\n2. WHEN Rust components are initialized THEN the system SHALL receive dependencies via constructor parameters\n3. WHEN testing UI components THEN the system SHALL support mock service implementations\n4. IF a component needs audio engine access THEN the system SHALL use an `AudioService` interface with injectable concrete implementations\n5. WHEN permission handling is needed THEN the system SHALL use an injectable `PermissionService` abstraction\n\n**Current Violations**:\n- All Dart screens directly import concrete `../../bridge/api.dart`\n- No service layer or repository pattern\n- Hard-coded dependencies throughout\n- Cannot test UI without real audio engine\n\n### Requirement 4: Extract Reusable UI Components and Utilities\n\n**User Story**: As a developer, I want shared UI patterns extracted into reusable components, so that I reduce duplication and ensure consistent behavior.\n\n#### Acceptance Criteria\n\n1. WHEN displaying error dialogs THEN the system SHALL use a shared `ErrorDialog` widget instead of duplicating AlertDialog code\n2. WHEN showing loading states THEN the system SHALL use a shared `LoadingIndicator` widget\n3. WHEN decorating containers THEN the system SHALL use shared decoration utilities instead of repeating BoxDecoration patterns\n4. WHEN formatting display strings THEN the system SHALL use utility functions in a `DisplayFormatter` class\n5. WHEN code duplication is measured THEN the system SHALL reduce duplicated lines by at least 100 lines (current: ~150 lines duplicated)\n\n**Current Violations**:\n- Error dialog pattern repeated 6+ times\n- Loading indicator boilerplate duplicated 4+ times\n- Container decoration patterns repeated 5+ times\n- Permission handling logic duplicated\n\n### Requirement 5: Refactor Oversized Functions\n\n**User Story**: As a developer, I want functions under 50 lines, so that I can understand, test, and maintain code more easily.\n\n#### Acceptance Criteria\n\n1. WHEN measuring function length THEN the system SHALL have no functions exceeding 50 lines\n2. WHEN `AudioEngine::start()` is analyzed THEN the system SHALL be refactored into helper functions (callback creation, stream setup, thread spawning)\n3. WHEN widget builders are analyzed THEN the system SHALL extract complex widget trees into separate methods or widgets\n4. IF a function has multiple responsibilities THEN the system SHALL split it according to Single Responsibility Principle\n5. WHEN refactoring is complete THEN the system SHALL maintain identical behavior with improved testability\n\n**Current Violations**:\n- `AudioEngine::start()`: 112 lines\n- `_buildProgressContent()`: 169 lines\n- `_buildClassificationDisplay()`: 90 lines\n\n### Requirement 6: Split Oversized Files\n\n**User Story**: As a developer, I want files under 500 lines, so that I can navigate and understand codebases more efficiently.\n\n#### Acceptance Criteria\n\n1. WHEN measuring file length THEN the system SHALL have no source files exceeding 500 lines (excluding test code)\n2. WHEN `calibration/procedure.rs` is analyzed THEN the system SHALL split into separate modules (validation, progress, finalization)\n3. WHEN `analysis/features.rs` is analyzed THEN the system SHALL split feature computation into separate modules per feature type\n4. IF a file contains multiple logical components THEN the system SHALL organize into sub-modules\n5. WHEN files are split THEN the system SHALL maintain public API compatibility\n\n**Current Violations**:\n- `calibration/procedure.rs`: 581 lines\n- `analysis/features.rs`: 576 lines\n- `calibration_screen.dart`: 464 lines (near limit)\n- `training_screen.dart`: 452 lines (near limit)\n\n### Requirement 7: Establish Pre-Commit Quality Gates\n\n**User Story**: As a developer, I want automated quality checks before commits, so that code quality violations are prevented from entering the repository.\n\n#### Acceptance Criteria\n\n1. WHEN committing code THEN the system SHALL automatically run linting checks and reject commits with violations\n2. WHEN committing code THEN the system SHALL automatically run formatters and reject improperly formatted code\n3. WHEN committing code THEN the system SHALL run all tests and reject commits with test failures\n4. IF code exceeds size limits THEN the system SHALL reject the commit with a clear error message\n5. WHEN pre-commit hooks are configured THEN the system SHALL check:\n   - `flutter analyze` passes\n   - `dart format --set-exit-if-changed` passes\n   - `cargo fmt -- --check` passes\n   - `cargo clippy -- -D warnings` passes\n   - `flutter test` passes\n   - No files > 500 lines\n   - No functions > 50 lines\n\n**Current Violations**:\n- No pre-commit hooks configured\n- No automated quality enforcement\n- Manual quality checks only\n\n### Requirement 8: Achieve Minimum Test Coverage\n\n**User Story**: As a developer, I want 80% minimum test coverage, so that I can confidently refactor and detect regressions early.\n\n#### Acceptance Criteria\n\n1. WHEN measuring test coverage THEN the system SHALL achieve at least 80% line coverage overall\n2. WHEN measuring critical path coverage THEN the system SHALL achieve at least 90% coverage for audio engine, calibration, and classification modules\n3. WHEN Dart code is analyzed THEN the system SHALL have unit tests for business logic (services, utilities)\n4. WHEN Dart UI is analyzed THEN the system SHALL have widget tests for screens and custom widgets\n5. WHEN Rust code is analyzed THEN the system SHALL have unit tests for all public APIs in `api.rs`\n6. IF global state is required for FFI THEN the system SHALL provide test helpers that initialize state safely\n\n**Current Violations**:\n- Dart: 0% coverage (no unit/widget tests)\n- Rust api.rs: Untestable due to global state\n- Overall: ~40% coverage (backend DSP only)\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: Each module has one clear purpose (e.g., `PermissionService` only handles permissions, `AudioService` only wraps audio API)\n- **Modular Design**: Services, utilities, and UI components are isolated and reusable\n- **Dependency Management**: All external dependencies injected via constructors or factory patterns\n- **Clear Interfaces**: Abstract interfaces defined for all services (e.g., `abstract class IAudioService`)\n- **Loose Coupling**: UI components depend on abstractions, not concrete implementations\n- **High Cohesion**: Related functionality grouped together (e.g., all error types in `errors.rs`)\n\n### Performance\n\n- **No Performance Regression**: Refactoring SHALL NOT increase audio latency beyond current < 20ms target\n- **Real-Time Safety Preserved**: Audio callback SHALL remain allocation-free and lock-free after refactoring\n- **DI Overhead**: Dependency injection SHALL add < 1ms overhead to startup time\n- **Memory Footprint**: Refactored code SHALL NOT increase memory usage by more than 5MB\n- **Build Time**: Refactoring SHALL NOT increase clean build time by more than 10%\n\n### Security\n\n- **Error Information Disclosure**: Error messages SHALL NOT expose sensitive implementation details to end users\n- **Input Validation**: All user inputs (BPM, audio samples) SHALL be validated before processing\n- **Panic Safety**: Production code SHALL contain zero `.unwrap()` or `.expect()` calls without documented safety invariants\n- **Thread Safety**: Shared state SHALL be protected by appropriate synchronization primitives or lock-free patterns\n\n### Reliability\n\n- **Graceful Degradation**: System SHALL handle errors without crashing (eliminate panic risks)\n- **Resource Cleanup**: All resources (audio streams, threads, locks) SHALL be properly cleaned up on error paths\n- **Error Recovery**: System SHALL attempt recovery from transient failures (e.g., retry audio stream initialization)\n- **Deterministic Behavior**: System SHALL produce identical results for identical inputs (no undefined behavior)\n\n### Maintainability\n\n- **Code Readability**: Functions under 50 lines, files under 500 lines\n- **Documentation**: All public APIs documented with doc comments\n- **Change Impact**: Localized changes (modifying one service doesn't require changes across multiple screens)\n- **Onboarding**: New developers can understand module boundaries within 1 day\n- **Debugging**: Structured logging enables tracing issues through the system\n\n### Testability\n\n- **Unit Test Isolation**: All components testable without external dependencies\n- **Mock Support**: All services have mockable interfaces\n- **Test Speed**: Unit test suite completes in < 10 seconds\n- **Test Reliability**: Tests produce deterministic results (no flaky tests)\n- **Coverage Metrics**: Automated coverage reporting integrated into CI/CD\n\n### Compatibility\n\n- **Backward Compatibility**: FFI bridge API remains compatible with existing Dart code during refactoring\n- **Real-Time Compatibility**: Refactored audio path maintains Oboe real-time guarantees\n- **Platform Support**: Changes SHALL NOT break Android 7.0+ (API 24+) compatibility\n- **Architecture Support**: ARM64-v8a and armeabi-v7a builds remain functional\n\n## Success Metrics\n\n- **Testability**: 0 global state variables in core business logic (currently 5)\n- **Test Coverage**: 80% overall, 90% for critical paths (currently ~40%)\n- **Code Duplication**: < 50 duplicated lines (currently ~150)\n- **Error Handling**: 100% of error paths return typed errors (currently 0%)\n- **Panic Safety**: 0 unwrap/expect calls in production code (currently 11+)\n- **Function Size**: 0 functions > 50 lines (currently 3)\n- **File Size**: 0 source files > 500 lines excluding tests (currently 2)\n- **Build Time**: Clean build < 2 minutes (monitor for regression)\n- **Performance**: Audio latency remains < 20ms (no regression)\n- **Quality Gates**: 100% of commits pass pre-commit checks after setup\n\n## Out of Scope\n\nThe following are explicitly OUT OF SCOPE for this refactoring:\n\n- **New Features**: No new sound categories, difficulty levels, or UI capabilities\n- **Performance Optimization**: No improvements to DSP algorithms or audio latency beyond maintaining current performance\n- **Platform Expansion**: No iOS, Windows, or web platform support\n- **UI/UX Redesign**: No changes to visual design or user workflows\n- **Persistent Storage**: No database or file-based calibration profile saving\n- **Analytics**: No usage tracking or telemetry infrastructure\n- **Internationalization**: No multi-language support\n- **Accessibility**: No screen reader or accessibility enhancements\n- **Background Operation**: No wake lock or audio focus management changes\n\nThis refactoring focuses exclusively on internal code quality, architecture, and testability improvements that enable future feature development.\n",
  "fileStats": {
    "size": 14992,
    "lines": 256,
    "lastModified": "2025-11-12T23:03:11.429Z"
  },
  "comments": []
}