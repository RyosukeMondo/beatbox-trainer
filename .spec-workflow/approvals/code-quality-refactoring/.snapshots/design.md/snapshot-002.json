{
  "id": "snapshot_1762990489200_4eyryke5k",
  "approvalId": "approval_1762989048824_4q5i32sf1",
  "approvalTitle": "Design: Code Quality Refactoring",
  "version": 2,
  "timestamp": "2025-11-12T23:34:49.200Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Code Quality Refactoring\n\n## Overview\n\nThis design establishes a testable, maintainable architecture for the Beatbox Trainer codebase while preserving the real-time audio performance guarantees that are core to the product. The refactoring introduces dependency injection, custom error handling, service abstractions, and modular component design to eliminate the critical issues identified in the code audit (5 global statics, 11+ unwrap() calls, ~150 lines duplication, 0% Dart test coverage).\n\n**Key Principle**: Refactor non-audio-path code for testability while maintaining zero-allocation, lock-free guarantees in the audio callback.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Real-Time Safety Guarantees** (tech.md:64-69):\n- ✅ Audio callback remains allocation-free and lock-free\n- ✅ Atomic operations (AtomicU64, AtomicU32) preserved for frame counter and BPM\n- ✅ Lock-free buffer pool pattern unchanged\n- ✅ Pre-allocated click samples and buffers maintained\n\n**4-Layer Native-First Stack** (tech.md:43-55):\n- ✅ Layer 1 (Oboe) unchanged\n- ✅ Layer 2 (Rust) refactored for testability with AppContext injection\n- ✅ Layer 3 (flutter_rust_bridge) enhanced with custom error types\n- ✅ Layer 4 (Dart/Flutter) enhanced with service layer\n\n**Architecture Pattern** (tech.md:57-69):\n- ✅ Event-driven, lock-free multi-threaded pipeline preserved\n- ✅ AudioThread, AnalysisThread, UI Thread separation maintained\n- ✅ MPSC → Broadcast pattern for multi-subscriber streams unchanged\n\n### Project Structure (structure.md)\n\nNew directories to add:\n```\nlib/\n├── services/          # NEW: Service layer abstractions\n│   ├── audio/\n│   ├── permission/\n│   └── error_handler/\n├── ui/\n│   ├── widgets/       # ENHANCED: Shared widgets extracted\n│   └── utils/         # NEW: Display formatters\nrust/src/\n├── error/             # NEW: Custom error types\n└── context/           # NEW: Dependency injection\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**Rust Audio Engine** (PRESERVE):\n- **AudioEngine** (`audio/engine.rs:59-76`): Atomic-based state management, builder pattern, lock-free callback\n- **BufferPool** (`audio/buffer_pool.rs`): Lock-free SPSC queues with dual-channel pattern\n- **Analysis Pipeline** (`analysis/mod.rs`): OnsetDetector → FeatureExtractor → Classifier → Quantizer\n- **Calibration State** (`calibration/state.rs`): RwLock-protected threshold storage\n\n**FFI Bridge** (ENHANCE):\n- **flutter_rust_bridge** annotations: #[frb(sync)], #[frb], #[frb(stream)]\n- **Serializable structs**: ClassificationResult, CalibrationProgress, BeatboxHit\n- **Stream pattern**: MPSC → Broadcast forwarding for multi-subscriber support\n\n**Dart Models** (PRESERVE):\n- **Value objects**: ClassificationResult, TimingFeedback, CalibrationProgress\n- **Display formatters**: `BeatboxHit.displayName`, `TimingFeedback.formattedError`\n- **Enum safety**: Proper pattern matching on BeatboxHit, TimingClassification\n\n### Integration Points\n\n**Rust FFI Layer** (`rust/src/api.rs`):\n- Replace global statics with AppContext struct\n- Add custom error types that map across FFI boundary\n- Inject dependencies into FFI functions\n\n**Dart Service Layer** (NEW):\n- Wrap FFI calls in service abstractions (AudioService, PermissionService)\n- Translate Rust errors to user-friendly messages\n- Provide mockable interfaces for testing\n\n**UI Components** (`lib/ui/screens/*.dart`):\n- Inject services via constructor\n- Use shared widgets for dialogs, loading, styling\n- Separate business logic from presentation\n\n## Architecture\n\n### Modular Design Principles\n\n1. **Single File Responsibility**:\n   - `error.rs`: All error types and translations\n   - `context.rs`: Dependency injection container\n   - `audio_service.dart`: Audio engine lifecycle only\n   - `permission_service.dart`: Permission handling only\n\n2. **Component Isolation**:\n   - Services don't depend on UI (can be tested independently)\n   - UI components receive services via constructor\n   - Error handlers are standalone utilities\n\n3. **Service Layer Separation**:\n   - **Data Access**: Rust FFI bridge (raw API calls)\n   - **Business Logic**: Dart services (validation, error translation, state management)\n   - **Presentation**: Dart widgets (UI rendering, user interaction)\n\n4. **Utility Modularity**:\n   - Display formatters separated from models\n   - Error translation separated from error types\n   - Shared widget library for common UI patterns\n\n### System Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Layer 4: Dart/Flutter UI\"\n        A[TrainingScreen] -->|injects| B[AudioService]\n        A -->|injects| C[PermissionService]\n        D[CalibrationScreen] -->|injects| B\n        D -->|injects| C\n        B -->|uses| E[ErrorHandler]\n        C -->|uses| E\n    end\n\n    subgraph \"Layer 3: Service Abstractions\"\n        B -->|calls| F[FFI Bridge]\n        C -->|calls| G[permission_handler pkg]\n        E -->|translates| H[Error Messages]\n    end\n\n    subgraph \"Layer 2: Rust Audio Engine\"\n        F -->|creates| I[AppContext]\n        I -->|contains| J[AudioEngine]\n        I -->|contains| K[CalibrationProcedure]\n        I -->|contains| L[CalibrationState]\n        J -->|lock-free| M[Audio Callback]\n        J -->|spawns| N[Analysis Thread]\n    end\n\n    subgraph \"Layer 1: Oboe C++ Audio I/O\"\n        M -->|drives| O[Input/Output Streams]\n    end\n\n    style M fill:#e8f5e9\n    style N fill:#e8f5e9\n    style B fill:#fff3e0\n    style C fill:#fff3e0\n    style I fill:#e3f2fd\n```\n\n### Dependency Flow\n\n**Before Refactoring** (Tight Coupling):\n```\nTrainingScreen → api.dart (global statics) → AudioEngine\n     ↓\nRaw Rust errors shown to user\n```\n\n**After Refactoring** (Loose Coupling):\n```\nTrainingScreen → IAudioService (interface) → AudioServiceImpl → AppContext → AudioEngine\n                      ↓\n                ErrorHandler.translateError()\n                      ↓\n                User-friendly message\n```\n\n## Components and Interfaces\n\n### Component 1: Custom Error Types (Rust)\n**File**: `rust/src/error.rs` (NEW)\n\n- **Purpose**: Replace `Result<T, String>` with typed error hierarchy, enable pattern matching and error code propagation\n- **Interfaces**:\n  ```rust\n  pub enum AudioError {\n      BpmInvalid { value: u32, min: u32, max: u32 },\n      AlreadyRunning,\n      NotRunning,\n      HardwareError(String),\n      PermissionDenied,\n      StreamOpenFailed { details: String },\n      LockPoisoned { component: String },\n  }\n\n  pub enum CalibrationError {\n      InsufficientSamples { collected: u8, needed: u8 },\n      InvalidFeatures { reason: String },\n      NotComplete,\n      AlreadyInProgress,\n  }\n\n  pub trait ErrorCode {\n      fn code(&self) -> u32;\n      fn message(&self) -> String;\n  }\n  ```\n- **Dependencies**: None\n- **Reuses**: Standard library Result, Display trait\n\n**Error Code Mapping**:\n```rust\nimpl ErrorCode for AudioError {\n    fn code(&self) -> u32 {\n        match self {\n            AudioError::BpmInvalid { .. } => 1001,\n            AudioError::AlreadyRunning => 1002,\n            AudioError::NotRunning => 1003,\n            AudioError::HardwareError(_) => 1004,\n            AudioError::PermissionDenied => 1005,\n            AudioError::StreamOpenFailed { .. } => 1006,\n            AudioError::LockPoisoned { .. } => 1007,\n        }\n    }\n\n    fn message(&self) -> String {\n        match self {\n            AudioError::BpmInvalid { value, min, max } =>\n                format!(\"BPM {} out of range [{}, {}]\", value, min, max),\n            AudioError::AlreadyRunning =>\n                \"Audio engine already running\".to_string(),\n            // ...\n        }\n    }\n}\n```\n\n### Component 2: AppContext (Rust DI Container)\n**File**: `rust/src/context.rs` (NEW)\n\n- **Purpose**: Replace global statics with injected context, enable unit testing with mock dependencies\n- **Interfaces**:\n  ```rust\n  pub struct AppContext {\n      audio_engine: Arc<Mutex<Option<AudioEngineState>>>,\n      calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>,\n      calibration_state: Arc<RwLock<CalibrationState>>,\n      classification_broadcast: Arc<Mutex<Option<broadcast::Sender<ClassificationResult>>>>,\n      calibration_broadcast: Arc<Mutex<Option<broadcast::Sender<CalibrationProgress>>>>,\n  }\n\n  impl AppContext {\n      pub fn new() -> Self { ... }\n\n      pub fn start_audio(&self, bpm: u32) -> Result<(), AudioError> { ... }\n      pub fn stop_audio(&self) -> Result<(), AudioError> { ... }\n      pub fn set_bpm(&self, bpm: u32) -> Result<(), AudioError> { ... }\n\n      pub async fn classification_stream(&self) -> impl futures::Stream<Item = ClassificationResult> { ... }\n\n      pub fn start_calibration(&self) -> Result<(), CalibrationError> { ... }\n      pub fn finish_calibration(&self) -> Result<(), CalibrationError> { ... }\n      pub async fn calibration_stream(&self) -> impl futures::Stream<Item = CalibrationProgress> { ... }\n  }\n  ```\n- **Dependencies**: AudioEngine, CalibrationProcedure, CalibrationState, tokio channels\n- **Reuses**: Existing audio engine, calibration logic, broadcast channel pattern\n\n**FFI Bridge Refactoring** (`rust/src/api.rs`):\n```rust\n// Global context (replaces 5 separate statics)\nstatic APP_CONTEXT: Lazy<AppContext> = Lazy::new(|| AppContext::new());\n\n#[flutter_rust_bridge::frb]\npub fn start_audio(bpm: u32) -> Result<(), AudioError> {\n    APP_CONTEXT.start_audio(bpm)\n}\n\n#[flutter_rust_bridge::frb]\npub fn stop_audio() -> Result<(), AudioError> {\n    APP_CONTEXT.stop_audio()\n}\n```\n\n**Testing Support**:\n```rust\n#[cfg(test)]\nimpl AppContext {\n    pub fn new_test() -> Self {\n        // Create isolated context for testing\n        Self::new()\n    }\n\n    pub fn with_mock_engine(mock: MockAudioEngine) -> Self {\n        // Inject mock for unit tests\n        // ...\n    }\n}\n```\n\n### Component 3: Safe Lock Handling Utilities\n**File**: `rust/src/context.rs` (helper methods)\n\n- **Purpose**: Eliminate unwrap() calls on locks, provide graceful error recovery\n- **Interfaces**:\n  ```rust\n  impl AppContext {\n      fn lock_audio_engine(&self) -> Result<MutexGuard<Option<AudioEngineState>>, AudioError> {\n          self.audio_engine.lock()\n              .map_err(|_| AudioError::LockPoisoned { component: \"audio_engine\".to_string() })\n      }\n\n      fn read_calibration(&self) -> Result<RwLockReadGuard<CalibrationState>, CalibrationError> {\n          self.calibration_state.read()\n              .map_err(|_| CalibrationError::StatePoisoned)\n      }\n\n      fn write_calibration(&self) -> Result<RwLockWriteGuard<CalibrationState>, CalibrationError> {\n          self.calibration_state.write()\n              .map_err(|_| CalibrationError::StatePoisoned)\n      }\n  }\n  ```\n- **Dependencies**: Standard library Mutex/RwLock\n- **Reuses**: Custom error types\n\n**Example Usage** (replaces unwrap):\n```rust\n// Before: PANIC RISK\nlet guard = AUDIO_ENGINE.lock().unwrap();\n\n// After: GRACEFUL ERROR\nlet guard = self.lock_audio_engine()?;\n```\n\n### Component 4: IAudioService Interface (Dart)\n**File**: `lib/services/audio/i_audio_service.dart` (NEW)\n\n- **Purpose**: Abstract FFI bridge for dependency injection and testing\n- **Interfaces**:\n  ```dart\n  abstract class IAudioService {\n    Future<void> startAudio({required int bpm});\n    Future<void> stopAudio();\n    Future<void> setBpm({required int bpm});\n    Stream<ClassificationResult> getClassificationStream();\n\n    Future<void> startCalibration();\n    Future<void> finishCalibration();\n    Stream<CalibrationProgress> getCalibrationStream();\n  }\n  ```\n- **Dependencies**: None (pure interface)\n- **Reuses**: Model types (ClassificationResult, CalibrationProgress)\n\n### Component 5: AudioServiceImpl (Dart)\n**File**: `lib/services/audio/audio_service_impl.dart` (NEW)\n\n- **Purpose**: Concrete implementation wrapping FFI bridge with error translation\n- **Interfaces**:\n  ```dart\n  class AudioServiceImpl implements IAudioService {\n    final ErrorHandler _errorHandler;\n\n    AudioServiceImpl({ErrorHandler? errorHandler})\n        : _errorHandler = errorHandler ?? ErrorHandler();\n\n    @override\n    Future<void> startAudio({required int bpm}) async {\n      try {\n        await api.startAudio(bpm: bpm);\n      } catch (e) {\n        throw AudioServiceException(\n          message: _errorHandler.translateAudioError(e.toString()),\n          originalError: e.toString(),\n        );\n      }\n    }\n\n    @override\n    Stream<ClassificationResult> getClassificationStream() {\n      return api.classificationStream();\n    }\n\n    // ... other methods\n  }\n  ```\n- **Dependencies**: FFI bridge (`api.dart`), ErrorHandler\n- **Reuses**: Existing FFI functions, stream pattern\n\n### Component 6: IPermissionService Interface (Dart)\n**File**: `lib/services/permission/i_permission_service.dart` (NEW)\n\n- **Purpose**: Abstract permission handling for testability\n- **Interfaces**:\n  ```dart\n  enum PermissionStatus { granted, denied, permanentlyDenied }\n\n  abstract class IPermissionService {\n    Future<PermissionStatus> checkMicrophonePermission();\n    Future<PermissionStatus> requestMicrophonePermission();\n    Future<void> openAppSettings();\n  }\n  ```\n- **Dependencies**: None (pure interface)\n- **Reuses**: None\n\n### Component 7: PermissionServiceImpl (Dart)\n**File**: `lib/services/permission/permission_service_impl.dart` (NEW)\n\n- **Purpose**: Concrete permission implementation using permission_handler package\n- **Interfaces**:\n  ```dart\n  class PermissionServiceImpl implements IPermissionService {\n    @override\n    Future<PermissionStatus> checkMicrophonePermission() async {\n      final status = await Permission.microphone.status;\n      if (status.isGranted) return PermissionStatus.granted;\n      if (status.isPermanentlyDenied) return PermissionStatus.permanentlyDenied;\n      return PermissionStatus.denied;\n    }\n\n    @override\n    Future<PermissionStatus> requestMicrophonePermission() async {\n      final result = await Permission.microphone.request();\n      if (result.isGranted) return PermissionStatus.granted;\n      if (result.isPermanentlyDenied) return PermissionStatus.permanentlyDenied;\n      return PermissionStatus.denied;\n    }\n\n    @override\n    Future<void> openAppSettings() async {\n      await openAppSettings();\n    }\n  }\n  ```\n- **Dependencies**: `permission_handler` package\n- **Reuses**: Existing permission_handler integration\n\n### Component 8: ErrorHandler (Dart)\n**File**: `lib/services/error_handler/error_handler.dart` (NEW)\n\n- **Purpose**: Translate technical Rust errors to user-friendly messages\n- **Interfaces**:\n  ```dart\n  class ErrorHandler {\n    String translateAudioError(String rustError) {\n      // Pattern match on Rust error messages\n      if (rustError.contains('BPM') && rustError.contains('out of range')) {\n        return 'Please choose a tempo between 40 and 240 BPM';\n      }\n      if (rustError.contains('already running')) {\n        return 'Audio is already active. Please stop it first.';\n      }\n      if (rustError.contains('AudioError::PermissionDenied')) {\n        return 'Microphone access required. Please enable in settings.';\n      }\n      if (rustError.contains('AudioError::StreamOpenFailed')) {\n        return 'Unable to access audio hardware. Please check if another app is using the microphone.';\n      }\n      if (rustError.contains('LockPoisoned')) {\n        return 'Internal error occurred. Please restart the app.';\n      }\n\n      // Fallback: sanitized generic message\n      return 'Audio engine error occurred. Please try restarting.';\n    }\n\n    String translateCalibrationError(String rustError) {\n      if (rustError.contains('InsufficientSamples')) {\n        return 'Not enough samples collected. Please continue making sounds.';\n      }\n      if (rustError.contains('InvalidFeatures')) {\n        return 'Sound quality too low. Please speak louder or move closer to the microphone.';\n      }\n      if (rustError.contains('NotComplete')) {\n        return 'Calibration not finished. Please complete all steps.';\n      }\n\n      return 'Calibration error occurred. Please try again.';\n    }\n  }\n  ```\n- **Dependencies**: None\n- **Reuses**: None\n\n### Component 9: Shared UI Widgets\n**Files**: `lib/ui/widgets/*.dart` (NEW)\n\n#### ErrorDialog Widget\n```dart\n// lib/ui/widgets/error_dialog.dart\nclass ErrorDialog extends StatelessWidget {\n  final String title;\n  final String message;\n  final VoidCallback? onRetry;\n\n  const ErrorDialog({\n    required this.message,\n    this.title = 'Error',\n    this.onRetry,\n    super.key,\n  });\n\n  static Future<void> show(BuildContext context, String message, {VoidCallback? onRetry}) {\n    return showDialog(\n      context: context,\n      builder: (context) => ErrorDialog(message: message, onRetry: onRetry),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AlertDialog(\n      title: Text(title),\n      content: Text(message),\n      actions: [\n        if (onRetry != null)\n          TextButton(\n            onPressed: () {\n              Navigator.of(context).pop();\n              onRetry!();\n            },\n            child: const Text('Retry'),\n          ),\n        TextButton(\n          onPressed: () => Navigator.of(context).pop(),\n          child: const Text('OK'),\n        ),\n      ],\n    );\n  }\n}\n```\n\n#### LoadingOverlay Widget\n```dart\n// lib/ui/widgets/loading_overlay.dart\nclass LoadingOverlay extends StatelessWidget {\n  final String? message;\n\n  const LoadingOverlay({this.message, super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          const CircularProgressIndicator(),\n          if (message != null) ...[\n            const SizedBox(height: 16),\n            Text(message!, style: const TextStyle(fontSize: 16)),\n          ],\n        ],\n      ),\n    );\n  }\n}\n```\n\n#### StatusCard Widget\n```dart\n// lib/ui/widgets/status_card.dart\nclass StatusCard extends StatelessWidget {\n  final Color backgroundColor;\n  final Color borderColor;\n  final IconData icon;\n  final String title;\n  final String? subtitle;\n\n  const StatusCard({\n    required this.backgroundColor,\n    required this.borderColor,\n    required this.icon,\n    required this.title,\n    this.subtitle,\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: const EdgeInsets.all(16),\n      decoration: BoxDecoration(\n        color: backgroundColor.withValues(alpha: 0.1),\n        borderRadius: BorderRadius.circular(12),\n        border: Border.all(color: borderColor, width: 2),\n      ),\n      child: Column(\n        children: [\n          Icon(icon, color: borderColor, size: 32),\n          const SizedBox(height: 8),\n          Text(\n            title,\n            style: TextStyle(\n              fontSize: 18,\n              fontWeight: FontWeight.bold,\n              color: borderColor,\n            ),\n          ),\n          if (subtitle != null) ...[\n            const SizedBox(height: 4),\n            Text(subtitle!, style: const TextStyle(fontSize: 14)),\n          ],\n        ],\n      ),\n    );\n  }\n}\n```\n\n### Component 10: Refactored TrainingScreen\n**File**: `lib/ui/screens/training_screen.dart` (MODIFIED)\n\n- **Purpose**: Inject services, use shared widgets, separate concerns\n- **Interfaces**: Same as current (StatefulWidget)\n- **Dependencies**: IAudioService, IPermissionService, ErrorHandler, shared widgets\n- **Reuses**: Existing UI layout structure, model types\n\n**Constructor Injection Pattern**:\n```dart\nclass TrainingScreen extends StatefulWidget {\n  final IAudioService audioService;\n  final IPermissionService permissionService;\n  final ErrorHandler errorHandler;\n\n  const TrainingScreen({\n    IAudioService? audioService,\n    IPermissionService? permissionService,\n    ErrorHandler? errorHandler,\n    super.key,\n  }) : audioService = audioService ?? AudioServiceImpl(),\n       permissionService = permissionService ?? PermissionServiceImpl(),\n       errorHandler = errorHandler ?? ErrorHandler();\n\n  @override\n  State<TrainingScreen> createState() => _TrainingScreenState();\n}\n```\n\n**Simplified Error Handling**:\n```dart\nFuture<void> _startTraining() async {\n  final status = await widget.permissionService.requestMicrophonePermission();\n\n  if (status != PermissionStatus.granted) {\n    if (status == PermissionStatus.permanentlyDenied) {\n      await _showPermissionDeniedDialog();\n    }\n    return;\n  }\n\n  try {\n    await widget.audioService.startAudio(bpm: _currentBpm);\n    final stream = widget.audioService.getClassificationStream();\n\n    setState(() {\n      _isTraining = true;\n      _classificationStream = stream;\n    });\n  } on AudioServiceException catch (e) {\n    if (mounted) {\n      await ErrorDialog.show(context, e.message, onRetry: _startTraining);\n    }\n  }\n}\n```\n\n### Component 11: File/Function Size Refactorings\n\n#### Split calibration/procedure.rs (581 lines → 3 files)\n```\nrust/src/calibration/\n├── procedure.rs (200 lines) - Main CalibrationProcedure struct\n├── validation.rs (150 lines) - Sample validation logic\n└── progress.rs (150 lines) - Progress tracking and reporting\n```\n\n**Module Organization**:\n```rust\n// calibration/mod.rs\npub mod procedure;\npub mod validation;\npub mod progress;\npub mod state;\n\npub use procedure::CalibrationProcedure;\npub use validation::SampleValidator;\npub use progress::{CalibrationProgress, CalibrationSound};\npub use state::CalibrationState;\n```\n\n#### Split analysis/features.rs (576 lines → 5 files)\n```\nrust/src/analysis/features/\n├── mod.rs (100 lines) - FeatureExtractor coordinator\n├── spectral.rs (150 lines) - Centroid, rolloff, flatness\n├── temporal.rs (120 lines) - ZCR, decay time\n├── fft.rs (100 lines) - FFT computation\n└── types.rs (100 lines) - Features struct, builder\n```\n\n#### Break down AudioEngine::start() (112 lines → 4 functions)\n```rust\nimpl AudioEngine {\n    pub fn start(\n        &mut self,\n        calibration: Arc<RwLock<CalibrationState>>,\n        result_sender: mpsc::UnboundedSender<ClassificationResult>,\n    ) -> Result<(), String> {\n        // Orchestration only (25 lines)\n        let input_stream = self.create_input_stream()?;\n        let output_stream = self.create_output_stream()?;\n\n        input_stream.start()?;\n        output_stream.start()?;\n\n        self.spawn_analysis_thread(calibration, result_sender);\n\n        self.input_stream = Some(input_stream);\n        self.output_stream = Some(output_stream);\n\n        Ok(())\n    }\n\n    fn create_input_stream(&self) -> Result<AudioStreamAsync<Input>, String> {\n        // 20 lines\n    }\n\n    fn create_output_stream(&self) -> Result<AudioStreamAsync<Output>, String> {\n        // 40 lines (callback closure)\n    }\n\n    fn spawn_analysis_thread(\n        &self,\n        calibration: Arc<RwLock<CalibrationState>>,\n        result_sender: mpsc::UnboundedSender<ClassificationResult>,\n    ) {\n        // 25 lines\n    }\n}\n```\n\n#### Break down _buildProgressContent (169 lines → 3 methods)\n```dart\nWidget _buildProgressContent(CalibrationProgress progress) {\n  return Column(\n    children: [\n      _buildOverallProgressHeader(progress),\n      _buildCurrentSoundInstructions(progress),\n      _buildProgressIndicator(progress),\n      _buildStatusMessage(progress),\n    ],\n  );\n}\n\nWidget _buildOverallProgressHeader(CalibrationProgress progress) {\n  // 30 lines - Step indicator + progress bar\n}\n\nWidget _buildCurrentSoundInstructions(CalibrationProgress progress) {\n  // 50 lines - Icon + instruction + description\n}\n\nWidget _buildProgressIndicator(CalibrationProgress progress) {\n  // 30 lines - Counter + progress bar\n}\n\nWidget _buildStatusMessage(CalibrationProgress progress) {\n  // 50 lines - StatusCard for completion/transition\n}\n```\n\n## Data Models\n\n### Error Models (Rust)\n\n```rust\n// rust/src/error.rs\n\n#[derive(Debug, Clone)]\npub enum AudioError {\n    BpmInvalid { value: u32, min: u32, max: u32 },\n    AlreadyRunning,\n    NotRunning,\n    HardwareError(String),\n    PermissionDenied,\n    StreamOpenFailed { details: String },\n    LockPoisoned { component: String },\n}\n\n#[derive(Debug, Clone)]\npub enum CalibrationError {\n    InsufficientSamples { collected: u8, needed: u8 },\n    InvalidFeatures { reason: String },\n    NotComplete,\n    AlreadyInProgress,\n    StatePoisoned,\n}\n\n// Error code mapping for FFI\npub trait ErrorCode {\n    fn code(&self) -> u32;\n    fn message(&self) -> String;\n}\n```\n\n### Service Exception Models (Dart)\n\n```dart\n// lib/services/exceptions.dart\n\nclass AudioServiceException implements Exception {\n  final String message;\n  final String originalError;\n  final int? errorCode;\n\n  const AudioServiceException({\n    required this.message,\n    required this.originalError,\n    this.errorCode,\n  });\n\n  @override\n  String toString() => message;\n}\n\nclass CalibrationServiceException implements Exception {\n  final String message;\n  final String originalError;\n\n  const CalibrationServiceException({\n    required this.message,\n    required this.originalError,\n  });\n\n  @override\n  String toString() => message;\n}\n```\n\n### Existing Models (NO CHANGES)\n\n- **ClassificationResult**: Preserved as-is\n- **TimingFeedback**: Preserved as-is\n- **CalibrationProgress**: Preserved as-is\n- **BeatboxHit enum**: Preserved as-is\n\n## Error Handling\n\n### Error Scenarios\n\n#### 1. BPM Validation Failure\n- **Scenario**: User sets BPM outside valid range (40-240)\n- **Rust Handling**:\n  ```rust\n  if bpm < 40 || bpm > 240 {\n      return Err(AudioError::BpmInvalid { value: bpm, min: 40, max: 240 });\n  }\n  ```\n- **Dart Translation**: \"Please choose a tempo between 40 and 240 BPM\"\n- **User Impact**: Error dialog with retry button, BPM slider resets to valid value\n\n#### 2. Audio Engine Already Running\n- **Scenario**: User clicks Start while audio is active\n- **Rust Handling**:\n  ```rust\n  let guard = self.lock_audio_engine()?;\n  if guard.is_some() {\n      return Err(AudioError::AlreadyRunning);\n  }\n  ```\n- **Dart Translation**: \"Audio is already active. Please stop it first.\"\n- **User Impact**: Error dialog, Start button remains disabled\n\n#### 3. Hardware Access Failure\n- **Scenario**: Another app is using microphone (e.g., phone call)\n- **Rust Handling**:\n  ```rust\n  let input_stream = self.create_input_stream()\n      .map_err(|e| AudioError::StreamOpenFailed { details: e.to_string() })?;\n  ```\n- **Dart Translation**: \"Unable to access audio hardware. Please check if another app is using the microphone.\"\n- **User Impact**: Error dialog with retry button\n\n#### 4. Lock Poisoned (Panic Recovery)\n- **Scenario**: Thread panicked while holding lock\n- **Rust Handling**:\n  ```rust\n  fn lock_audio_engine(&self) -> Result<MutexGuard<_>, AudioError> {\n      self.audio_engine.lock()\n          .map_err(|_| AudioError::LockPoisoned { component: \"audio_engine\".to_string() })\n  }\n  ```\n- **Dart Translation**: \"Internal error occurred. Please restart the app.\"\n- **User Impact**: Error dialog, app restart recommended\n\n#### 5. Permission Permanently Denied\n- **Scenario**: User denied microphone permission multiple times\n- **Dart Handling**:\n  ```dart\n  final status = await permissionService.requestMicrophonePermission();\n  if (status == PermissionStatus.permanentlyDenied) {\n      await showPermissionSettingsDialog();\n  }\n  ```\n- **User Impact**: Dialog with \"Open Settings\" button\n\n#### 6. Calibration Incomplete\n- **Scenario**: User tries to finish calibration with < 10 samples\n- **Rust Handling**:\n  ```rust\n  if !self.is_complete() {\n      return Err(CalibrationError::NotComplete);\n  }\n  ```\n- **Dart Translation**: \"Calibration not finished. Please complete all steps.\"\n- **User Impact**: Error dialog, stays on calibration screen\n\n### Error Propagation Chain\n\n```\nRust Error → Result<T, AudioError>\n    ↓\nFFI Bridge → Dart Exception\n    ↓\nErrorHandler.translate() → User-friendly String\n    ↓\nErrorDialog.show() → UI Display\n```\n\n## Testing Strategy\n\n### Unit Testing\n\n#### Rust Tests\n**Target Coverage**: 90% for error handling, AppContext, lock management\n\n```rust\n// rust/src/context.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_appcontext_start_audio_validates_bpm() {\n        let ctx = AppContext::new_test();\n\n        let result = ctx.start_audio(0);\n        assert!(matches!(result, Err(AudioError::BpmInvalid { value: 0, .. })));\n\n        let result = ctx.start_audio(300);\n        assert!(matches!(result, Err(AudioError::BpmInvalid { value: 300, .. })));\n    }\n\n    #[test]\n    fn test_appcontext_prevents_double_start() {\n        let ctx = AppContext::new_test();\n\n        ctx.start_audio(120).unwrap();\n        let result = ctx.start_audio(120);\n\n        assert!(matches!(result, Err(AudioError::AlreadyRunning)));\n    }\n\n    #[test]\n    fn test_lock_poisoning_recovery() {\n        let ctx = AppContext::new_test();\n\n        // Simulate poisoned lock (requires unsafe or panic injection)\n        // ...\n\n        let result = ctx.lock_audio_engine();\n        assert!(matches!(result, Err(AudioError::LockPoisoned { .. })));\n    }\n}\n```\n\n#### Dart Service Tests\n**Target Coverage**: 80% for service layer, error translation\n\n```dart\n// test/services/audio_service_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:mocktail/mocktail.dart';\n\nclass MockFFIBridge extends Mock implements FFIBridge {}\nclass MockErrorHandler extends Mock implements ErrorHandler {}\n\nvoid main() {\n  late MockFFIBridge mockBridge;\n  late MockErrorHandler mockErrorHandler;\n  late AudioServiceImpl service;\n\n  setUp(() {\n    mockBridge = MockFFIBridge();\n    mockErrorHandler = MockErrorHandler();\n    service = AudioServiceImpl(\n      bridge: mockBridge,\n      errorHandler: mockErrorHandler,\n    );\n  });\n\n  test('startAudio throws AudioServiceException on invalid BPM', () async {\n    when(() => mockBridge.startAudio(bpm: 0))\n        .thenThrow(Exception('AudioError::BpmInvalid'));\n    when(() => mockErrorHandler.translateAudioError(any()))\n        .thenReturn('Please choose a tempo between 40 and 240 BPM');\n\n    expect(\n      () => service.startAudio(bpm: 0),\n      throwsA(isA<AudioServiceException>()),\n    );\n  });\n\n  test('getClassificationStream returns stream from bridge', () {\n    final mockStream = Stream<ClassificationResult>.empty();\n    when(() => mockBridge.classificationStream()).thenAnswer((_) => mockStream);\n\n    final stream = service.getClassificationStream();\n\n    expect(stream, equals(mockStream));\n  });\n}\n```\n\n### Integration Testing\n\n#### Rust Integration Tests\n**Target**: Full lifecycle (start → classify → stop)\n\n```rust\n// rust/tests/integration_test.rs\n#[tokio::test]\nasync fn test_full_audio_lifecycle() {\n    let ctx = AppContext::new();\n\n    // Start audio engine\n    ctx.start_audio(120).unwrap();\n\n    // Subscribe to classification stream\n    let mut stream = ctx.classification_stream().await;\n\n    // Simulate audio input (inject test samples)\n    // ...\n\n    // Verify classification results arrive\n    tokio::time::timeout(Duration::from_secs(5), async {\n        let result = stream.next().await;\n        assert!(result.is_some());\n    }).await.unwrap();\n\n    // Stop audio engine\n    ctx.stop_audio().unwrap();\n\n    // Verify stream closed\n    let result = stream.next().await;\n    assert!(result.is_none());\n}\n```\n\n#### Dart Widget Tests\n**Target**: Screen behavior with mocked services\n\n```dart\n// test/ui/screens/training_screen_test.dart\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  late MockAudioService mockAudioService;\n  late MockPermissionService mockPermissionService;\n\n  setUp(() {\n    mockAudioService = MockAudioService();\n    mockPermissionService = MockPermissionService();\n  });\n\n  testWidgets('shows error dialog on audio start failure', (tester) async {\n    when(() => mockPermissionService.requestMicrophonePermission())\n        .thenAnswer((_) async => PermissionStatus.granted);\n    when(() => mockAudioService.startAudio(bpm: any(named: 'bpm')))\n        .thenThrow(AudioServiceException(\n          message: 'Audio hardware unavailable',\n          originalError: 'StreamOpenFailed',\n        ));\n\n    await tester.pumpWidget(MaterialApp(\n      home: TrainingScreen(\n        audioService: mockAudioService,\n        permissionService: mockPermissionService,\n      ),\n    ));\n\n    // Tap start button\n    await tester.tap(find.byIcon(Icons.play_arrow));\n    await tester.pumpAndSettle();\n\n    // Verify error dialog shown\n    expect(find.text('Audio hardware unavailable'), findsOneWidget);\n    expect(find.text('Retry'), findsOneWidget);\n  });\n}\n```\n\n### End-to-End Testing\n\n#### Manual Test Scenarios\n**Target**: Real device validation\n\n1. **Happy Path**:\n   - Grant microphone permission\n   - Start audio at 120 BPM\n   - Make kick/snare/hihat sounds\n   - Verify classification accuracy > 90%\n   - Stop audio cleanly\n\n2. **Permission Denial**:\n   - Deny microphone permission\n   - Verify app doesn't crash\n   - Verify user-friendly error message\n   - Tap \"Open Settings\"\n   - Grant permission\n   - Retry successfully\n\n3. **Hardware Conflict**:\n   - Start phone call while app is running\n   - Verify graceful error handling\n   - End call\n   - Retry audio engine start\n   - Verify recovery\n\n4. **Calibration Flow**:\n   - Complete 10 kick samples\n   - Complete 10 snare samples\n   - Complete 10 hihat samples\n   - Verify thresholds computed\n   - Start training\n   - Verify classification uses calibrated thresholds\n\n## Implementation Notes\n\n### Phase 1: Error Infrastructure (Priority P0)\n**Estimated Effort**: 2 days\n\n1. Create `rust/src/error.rs` with custom error types\n2. Implement ErrorCode trait\n3. Replace all `Result<T, String>` with typed errors\n4. Replace all `.unwrap()` with `?` operator or proper handling\n5. Add error translation in flutter_rust_bridge annotations\n\n### Phase 2: Dependency Injection (Priority P0)\n**Estimated Effort**: 3 days\n\n1. Create `rust/src/context.rs` with AppContext struct\n2. Move global statics into AppContext fields\n3. Implement lock helper methods\n4. Refactor `api.rs` to use single APP_CONTEXT static\n5. Add test helpers (new_test, with_mock_engine)\n\n### Phase 3: Dart Service Layer (Priority P1)\n**Estimated Effort**: 2 days\n\n1. Create service interfaces (IAudioService, IPermissionService)\n2. Implement concrete services (AudioServiceImpl, PermissionServiceImpl)\n3. Create ErrorHandler with translation logic\n4. Create service exception types\n5. Refactor TrainingScreen to use dependency injection\n6. Refactor CalibrationScreen to use dependency injection\n\n### Phase 4: Shared UI Components (Priority P1)\n**Estimated Effort**: 1 day\n\n1. Extract ErrorDialog widget\n2. Extract LoadingOverlay widget\n3. Extract StatusCard widget\n4. Update screens to use shared widgets\n5. Remove duplicated code\n\n### Phase 5: File/Function Size Refactoring (Priority P2)\n**Estimated Effort**: 3 days\n\n1. Split `calibration/procedure.rs` into 3 modules\n2. Split `analysis/features.rs` into 5 modules\n3. Break down `AudioEngine::start()` into helper methods\n4. Break down `_buildProgressContent()` into sub-methods\n5. Break down `_buildClassificationDisplay()` into sub-methods\n6. Update imports and module structure\n\n### Phase 6: Testing Infrastructure (Priority P1)\n**Estimated Effort**: 4 days\n\n1. Create pre-commit hook script\n2. Add Rust unit tests for AppContext\n3. Add Dart unit tests for services\n4. Add Dart widget tests for screens\n5. Configure coverage reporting\n6. Document test execution in README\n\n**Total Estimated Effort**: 15 days\n\n## Success Criteria\n\n- ✅ 0 unwrap/expect calls in production Rust code\n- ✅ 0 global state variables (replaced with 1 AppContext)\n- ✅ All FFI functions return typed errors (AudioError, CalibrationError)\n- ✅ 80% overall test coverage, 90% for critical paths\n- ✅ < 50 duplicated lines (currently ~150)\n- ✅ 0 functions > 50 lines\n- ✅ 0 source files > 500 lines (excluding tests)\n- ✅ Audio latency remains < 20ms (no regression)\n- ✅ Pre-commit hooks block commits with quality violations\n",
  "fileStats": {
    "size": 35980,
    "lines": 1201,
    "lastModified": "2025-11-12T23:10:41.272Z"
  },
  "comments": []
}