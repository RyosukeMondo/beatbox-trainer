{
  "id": "snapshot_1763037189455_8qipsnudx",
  "approvalId": "approval_1763036944145_ennovkb9o",
  "approvalTitle": "UAT Readiness Design Document",
  "version": 2,
  "timestamp": "2025-11-13T12:33:09.455Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design: UAT Readiness for Beatbox Trainer\n\n## Overview\nTechnical design for implementing all UAT readiness requirements, including calibration onboarding, real-time feedback enhancements, debug mode, classifier level selection, automated testing, and UAT documentation.\n\n## Architecture Principles\n\n### Existing Patterns (Maintain Consistency)\n1. **Dependency Injection**: Constructor-based with optional parameters and default implementations\n2. **State Management**: StatefulWidget with local state + StreamBuilder for Rust streams\n3. **Error Handling**: Three-layer strategy (Rust typed errors → Service translation → UI-friendly messages)\n4. **Service Layer**: Interface-implementation pattern with mockable dependencies\n5. **FFI Communication**: flutter_rust_bridge with Tokio-backed stream forwarding\n\n### New Patterns (For UAT Features)\n1. **Navigation**: Add go_router for Settings/Debug/Calibration screens\n2. **Persistence**: shared_preferences for calibration data and settings\n3. **Debug Overlay**: Stack-based overlay with real-time metrics\n4. **Test Infrastructure**: Mocktail-based unit/widget tests with 80%+ coverage\n\n## System Architecture\n\n### High-Level Component Diagram\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                        Flutter UI Layer                          │\n├─────────────────────────────────────────────────────────────────┤\n│  ┌──────────────┐  ┌──────────────┐  ┌─────────────────────┐  │\n│  │ Training     │  │ Calibration  │  │ Settings            │  │\n│  │ Screen       │  │ Screen       │  │ Screen              │  │\n│  │              │  │              │  │                     │  │\n│  │ - Real-time  │  │ - 3-step     │  │ - BPM prefs         │  │\n│  │   feedback   │  │   workflow   │  │ - Debug toggle      │  │\n│  │ - BPM ctrl   │  │ - Progress   │  │ - Recalibrate       │  │\n│  │ - Debug      │  │   indicator  │  │ - Level selection   │  │\n│  │   overlay    │  │              │  │                     │  │\n│  └──────┬───────┘  └──────┬───────┘  └──────────┬──────────┘  │\n│         │                 │                     │              │\n├─────────┴─────────────────┴─────────────────────┴──────────────┤\n│                      Service Layer                               │\n├─────────────────────────────────────────────────────────────────┤\n│  ┌──────────────────┐  ┌────────────────────┐  ┌─────────────┐│\n│  │ IAudioService    │  │ IStorageService    │  │ ISettings   ││\n│  │                  │  │                    │  │ Service     ││\n│  │ - startAudio()   │  │ - saveCalibration()│  │ - getBpm()  ││\n│  │ - stopAudio()    │  │ - loadCalibration()│  │ - getDebug()││\n│  │ - setBpm()       │  │ - saveSettings()   │  │ - setLevel()││\n│  │ - classification │  │                    │  │             ││\n│  │   Stream()       │  │                    │  │             ││\n│  └────────┬─────────┘  └─────────┬──────────┘  └──────┬──────┘│\n│           │                      │                    │        │\n├───────────┴──────────────────────┴────────────────────┴────────┤\n│                    FFI Bridge (flutter_rust_bridge)             │\n├─────────────────────────────────────────────────────────────────┤\n│  ┌──────────────────────────────────────────────────────────┐  │\n│  │                 Rust API (api.rs)                        │  │\n│  │  - start_audio()                                         │  │\n│  │  - classification_stream()                               │  │\n│  │  - start_calibration()                                   │  │\n│  │  - finish_calibration()                                  │  │\n│  └────────────────────────┬─────────────────────────────────┘  │\n├────────────────────────────┴─────────────────────────────────────┤\n│                    Rust Core (AppContext)                        │\n├──────────────────────────────────────────────────────────────────┤\n│  ┌─────────────────┐  ┌──────────────┐  ┌──────────────────┐  │\n│  │ AudioEngine     │  │ Classifier   │  │ Calibration      │  │\n│  │ (Oboe)          │  │              │  │ Procedure        │  │\n│  │ - INPUT stream  │  │ - Level 1/2  │  │ - Sample         │  │\n│  │ - OUTPUT stream │  │ - Thresholds │  │   collection     │  │\n│  │ - Metronome     │  │              │  │ - Threshold      │  │\n│  │                 │  │              │  │   computation    │  │\n│  └─────────────────┘  └──────────────┘  └──────────────────┘  │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n## Detailed Component Designs\n\n### 1. Calibration Onboarding System\n\n#### 1.1 Calibration Storage Service\n\n**Interface**: `lib/services/storage/i_storage_service.dart`\n```dart\nabstract class IStorageService {\n  /// Initialize storage (must be called before use)\n  Future<void> init();\n\n  /// Check if calibration data exists\n  Future<bool> hasCalibration();\n\n  /// Save calibration data with level\n  Future<void> saveCalibration(CalibrationData data);\n\n  /// Load calibration data\n  Future<CalibrationData?> loadCalibration();\n\n  /// Clear calibration (for recalibration)\n  Future<void> clearCalibration();\n}\n\nclass CalibrationData {\n  final int level;              // 1 or 2\n  final DateTime timestamp;     // When calibrated\n  final Map<String, double> thresholds;  // Sound type → threshold\n}\n```\n\n**Implementation**: `lib/services/storage/storage_service_impl.dart`\n- Uses `shared_preferences` for key-value storage\n- Serializes CalibrationData to JSON\n- Keys: `calibration_data`, `calibration_level`, `calibration_timestamp`\n\n**Rust Integration**:\n```rust\n// Add to rust/src/api.rs\n#[flutter_rust_bridge::frb]\npub fn load_calibration_state(json: String) -> Result<(), CalibrationError> {\n    let data: CalibrationData = serde_json::from_str(&json)?;\n    APP_CONTEXT.load_calibration(data)?;\n    Ok(())\n}\n\n#[flutter_rust_bridge::frb]\npub fn get_calibration_state() -> Result<String, CalibrationError> {\n    let data = APP_CONTEXT.get_calibration_state()?;\n    Ok(serde_json::to_string(&data)?)\n}\n```\n\n#### 1.2 Onboarding Flow\n\n**Router Configuration**: `lib/main.dart`\n```dart\nimport 'package:go_router/go_router.dart';\n\nfinal GoRouter _router = GoRouter(\n  routes: [\n    GoRoute(\n      path: '/',\n      builder: (context, state) => SplashScreen(),  // Check calibration\n    ),\n    GoRoute(\n      path: '/onboarding',\n      builder: (context, state) => OnboardingScreen(),\n    ),\n    GoRoute(\n      path: '/calibration',\n      builder: (context, state) => CalibrationScreen(),\n    ),\n    GoRoute(\n      path: '/training',\n      builder: (context, state) => TrainingScreen(),\n    ),\n    GoRoute(\n      path: '/settings',\n      builder: (context, state) => SettingsScreen(),\n    ),\n  ],\n);\n\nclass BeatboxTrainerApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,\n    );\n  }\n}\n```\n\n**Splash Screen Logic**: `lib/ui/screens/splash_screen.dart`\n```dart\nclass SplashScreen extends StatefulWidget {\n  @override\n  State<SplashScreen> createState() => _SplashScreenState();\n}\n\nclass _SplashScreenState extends State<SplashScreen> {\n  @override\n  void initState() {\n    super.initState();\n    _checkCalibrationAndNavigate();\n  }\n\n  Future<void> _checkCalibrationAndNavigate() async {\n    final storageService = StorageServiceImpl();\n    await storageService.init();\n\n    final hasCalibration = await storageService.hasCalibration();\n\n    if (hasCalibration) {\n      // Load calibration into Rust\n      final data = await storageService.loadCalibration();\n      await api.loadCalibrationState(jsonEncode(data));\n\n      // Navigate to training\n      if (mounted) context.go('/training');\n    } else {\n      // First-time user - show onboarding\n      if (mounted) context.go('/onboarding');\n    }\n  }\n}\n```\n\n**Onboarding Screen**: `lib/ui/screens/onboarding_screen.dart`\n```dart\nclass OnboardingScreen extends StatelessWidget {\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Padding(\n        padding: EdgeInsets.all(24.0),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(Icons.mic, size: 100, color: Colors.deepPurple),\n            SizedBox(height: 32),\n            Text(\n              'Welcome to Beatbox Trainer!',\n              style: Theme.of(context).textTheme.headlineMedium,\n              textAlign: TextAlign.center,\n            ),\n            SizedBox(height: 16),\n            Text(\n              'Before you start training, we need to calibrate '\n              'the app to recognize your beatbox sounds.',\n              style: Theme.of(context).textTheme.bodyLarge,\n              textAlign: TextAlign.center,\n            ),\n            SizedBox(height: 32),\n            _buildCalibrationSteps(context),\n            SizedBox(height: 48),\n            ElevatedButton(\n              onPressed: () => context.go('/calibration'),\n              child: Text('Start Calibration'),\n              style: ElevatedButton.styleFrom(\n                minimumSize: Size(double.infinity, 56),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildCalibrationSteps(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        _buildStep(context, '1', 'Make 10 KICK sounds'),\n        _buildStep(context, '2', 'Make 10 SNARE sounds'),\n        _buildStep(context, '3', 'Make 10 HI-HAT sounds'),\n      ],\n    );\n  }\n}\n```\n\n#### 1.3 Enhanced Calibration Screen\n\n**Modifications to**: `lib/ui/screens/calibration_screen.dart`\n\n**Add Progress Persistence**:\n```dart\nclass _CalibrationScreenState extends State<CalibrationScreen> {\n  final IStorageService _storageService;\n\n  // ... existing state ...\n\n  Future<void> _finishCalibration() async {\n    try {\n      await api.finishCalibration();\n\n      // Save to persistent storage\n      final calibrationJson = await api.getCalibrationState();\n      final data = CalibrationData.fromJson(jsonDecode(calibrationJson));\n      await _storageService.saveCalibration(data);\n\n      if (mounted) {\n        // Show success and navigate to training\n        await showDialog(\n          context: context,\n          builder: (context) => AlertDialog(\n            title: Text('Calibration Complete!'),\n            content: Text('You\\'re ready to start training.'),\n            actions: [\n              TextButton(\n                onPressed: () {\n                  Navigator.of(context).pop();\n                  context.go('/training');\n                },\n                child: Text('Start Training'),\n              ),\n            ],\n          ),\n        );\n      }\n    } catch (e) {\n      // Handle error\n    }\n  }\n}\n```\n\n### 2. Real-Time Classification Feedback Enhancements\n\n#### 2.1 Enhanced Feedback Display\n\n**Modifications to**: `lib/ui/screens/training_screen.dart`\n\n**Add Animation Controller**:\n```dart\nclass _TrainingScreenState extends State<TrainingScreen>\n    with SingleTickerProviderStateMixin {\n  late AnimationController _feedbackAnimationController;\n  late Animation<double> _feedbackOpacity;\n\n  @override\n  void initState() {\n    super.initState();\n    _feedbackAnimationController = AnimationController(\n      duration: Duration(milliseconds: 500),\n      vsync: this,\n    );\n    _feedbackOpacity = Tween<double>(begin: 1.0, end: 0.3).animate(\n      CurvedAnimation(\n        parent: _feedbackAnimationController,\n        curve: Curves.easeOut,\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _feedbackAnimationController.dispose();\n    super.dispose();\n  }\n}\n```\n\n**Enhanced Classification Display**:\n```dart\nWidget _buildClassificationDisplay(ClassificationResult result) {\n  // Restart fade animation on new result\n  _feedbackAnimationController.forward(from: 0.0);\n\n  return AnimatedBuilder(\n    animation: _feedbackOpacity,\n    builder: (context, child) {\n      return Opacity(\n        opacity: _feedbackOpacity.value,\n        child: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              _buildSoundTypeDisplay(result),\n              SizedBox(height: 32),\n              _buildTimingFeedbackDisplay(result),\n              SizedBox(height: 16),\n              _buildConfidenceIndicator(result),  // NEW\n            ],\n          ),\n        ),\n      );\n    },\n  );\n}\n\nWidget _buildConfidenceIndicator(ClassificationResult result) {\n  final confidence = result.confidence ?? 0.0;  // Add to Rust struct\n  final color = confidence > 0.8 ? Colors.green :\n                confidence > 0.5 ? Colors.orange : Colors.red;\n\n  return Row(\n    mainAxisAlignment: MainAxisAlignment.center,\n    children: [\n      Text('Confidence: ', style: TextStyle(fontSize: 16)),\n      Container(\n        width: 100,\n        height: 8,\n        decoration: BoxDecoration(\n          color: Colors.grey[300],\n          borderRadius: BorderRadius.circular(4),\n        ),\n        child: FractionallySizedBox(\n          widthFactor: confidence,\n          alignment: Alignment.centerLeft,\n          child: Container(\n            decoration: BoxDecoration(\n              color: color,\n              borderRadius: BorderRadius.circular(4),\n            ),\n          ),\n        ),\n      ),\n      SizedBox(width: 8),\n      Text('${(confidence * 100).toInt()}%'),\n    ],\n  );\n}\n```\n\n#### 2.2 Rust Confidence Score Addition\n\n**Modify**: `rust/src/analysis/mod.rs`\n```rust\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct ClassificationResult {\n    pub sound: BeatboxHit,\n    pub timing: TimingFeedback,\n    pub confidence: f32,  // NEW: 0.0 to 1.0\n}\n```\n\n**Modify**: `rust/src/analysis/classifier.rs`\n```rust\nimpl Classifier {\n    fn classify_level1(&self, features: &AudioFeatures) -> ClassificationResult {\n        let kick_score = /* ... existing logic ... */;\n        let snare_score = /* ... */;\n        let hihat_score = /* ... */;\n\n        let (sound, max_score) = /* ... determine winner ... */;\n\n        // Normalize score to 0.0-1.0 confidence\n        let confidence = (max_score / (kick_score + snare_score + hihat_score))\n            .clamp(0.0, 1.0);\n\n        ClassificationResult {\n            sound,\n            timing: self.compute_timing(),\n            confidence,\n        }\n    }\n}\n```\n\n### 3. Debug Mode System\n\n#### 3.1 Debug Service\n\n**Interface**: `lib/services/debug/i_debug_service.dart`\n```dart\nabstract class IDebugService {\n  /// Get real-time audio metrics\n  Stream<AudioMetrics> getAudioMetricsStream();\n\n  /// Get onset detection events\n  Stream<OnsetEvent> getOnsetEventsStream();\n\n  /// Export debug logs to file\n  Future<String> exportLogs();\n}\n\nclass AudioMetrics {\n  final double rms;              // Current audio level\n  final double spectralCentroid; // Brightness\n  final double spectralFlux;     // Change rate\n  final int frameNumber;         // Sample count\n  final DateTime timestamp;\n}\n\nclass OnsetEvent {\n  final DateTime timestamp;\n  final double energy;\n  final AudioFeatures features;\n  final ClassificationResult? classification;\n}\n```\n\n**Rust API Addition**: `rust/src/api.rs`\n```rust\n#[flutter_rust_bridge::frb]\npub fn audio_metrics_stream(sink: StreamSink<AudioMetrics>) {\n    TOKIO_RUNTIME.spawn(async move {\n        let stream = APP_CONTEXT.audio_metrics_stream().await;\n        tokio::pin!(stream);\n        while let Some(metrics) = stream.next().await {\n            sink.add(metrics);\n        }\n    });\n}\n\n#[flutter_rust_bridge::frb]\npub fn onset_events_stream(sink: StreamSink<OnsetEvent>) {\n    TOKIO_RUNTIME.spawn(async move {\n        let stream = APP_CONTEXT.onset_events_stream().await;\n        tokio::pin!(stream);\n        while let Some(event) = stream.next().await {\n            sink.add(event);\n        }\n    });\n}\n```\n\n#### 3.2 Debug Overlay Widget\n\n**File**: `lib/ui/widgets/debug_overlay.dart`\n```dart\nclass DebugOverlay extends StatelessWidget {\n  final IDebugService debugService;\n  final VoidCallback onClose;\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        // Main content (pass through touches)\n\n        // Debug overlay positioned at top\n        Positioned(\n          top: 0,\n          left: 0,\n          right: 0,\n          child: Container(\n            color: Colors.black.withOpacity(0.85),\n            padding: EdgeInsets.all(16),\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                  children: [\n                    Text(\n                      'Debug Metrics',\n                      style: TextStyle(\n                        color: Colors.white,\n                        fontSize: 18,\n                        fontWeight: FontWeight.bold,\n                      ),\n                    ),\n                    IconButton(\n                      icon: Icon(Icons.close, color: Colors.white),\n                      onPressed: onClose,\n                    ),\n                  ],\n                ),\n                Divider(color: Colors.white54),\n                _buildAudioMetrics(),\n                SizedBox(height: 16),\n                _buildOnsetLog(),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildAudioMetrics() {\n    return StreamBuilder<AudioMetrics>(\n      stream: debugService.getAudioMetricsStream(),\n      builder: (context, snapshot) {\n        if (!snapshot.hasData) {\n          return Text('No audio data', style: TextStyle(color: Colors.white54));\n        }\n\n        final metrics = snapshot.data!;\n        return Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            _buildMetricRow('RMS Level', metrics.rms.toStringAsFixed(3)),\n            _buildMetricRow('Centroid', metrics.spectralCentroid.toStringAsFixed(1)),\n            _buildMetricRow('Flux', metrics.spectralFlux.toStringAsFixed(3)),\n            _buildMetricRow('Frame', metrics.frameNumber.toString()),\n            SizedBox(height: 8),\n            _buildRmsLevelMeter(metrics.rms),\n          ],\n        );\n      },\n    );\n  }\n\n  Widget _buildRmsLevelMeter(double rms) {\n    return Container(\n      height: 24,\n      decoration: BoxDecoration(\n        color: Colors.grey[800],\n        borderRadius: BorderRadius.circular(4),\n      ),\n      child: FractionallySizedBox(\n        widthFactor: (rms * 10).clamp(0.0, 1.0),\n        alignment: Alignment.centerLeft,\n        child: Container(\n          decoration: BoxDecoration(\n            color: Colors.greenAccent,\n            borderRadius: BorderRadius.circular(4),\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _buildOnsetLog() {\n    return Container(\n      height: 150,\n      decoration: BoxDecoration(\n        color: Colors.grey[900],\n        borderRadius: BorderRadius.circular(8),\n      ),\n      child: StreamBuilder<OnsetEvent>(\n        stream: debugService.getOnsetEventsStream(),\n        builder: (context, snapshot) {\n          // Display scrollable log of onset events\n          return ListView(/* ... */);\n        },\n      ),\n    );\n  }\n}\n```\n\n#### 3.3 Settings Integration\n\n**Modifications to**: `lib/services/settings/i_settings_service.dart`\n```dart\nabstract class ISettingsService {\n  Future<bool> getDebugMode();\n  Future<void> setDebugMode(bool enabled);\n  // ... other settings ...\n}\n```\n\n**In TrainingScreen**:\n```dart\nclass _TrainingScreenState extends State<TrainingScreen> {\n  bool _debugMode = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadDebugMode();\n  }\n\n  Future<void> _loadDebugMode() async {\n    final settings = SettingsServiceImpl();\n    await settings.init();\n    final enabled = await settings.getDebugMode();\n    setState(() => _debugMode = enabled);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _debugMode\n          ? DebugOverlay(\n              debugService: DebugServiceImpl(),\n              onClose: () => setState(() => _debugMode = false),\n              child: _buildTrainingContent(),\n            )\n          : _buildTrainingContent(),\n    );\n  }\n}\n```\n\n### 4. Settings Screen\n\n**File**: `lib/ui/screens/settings_screen.dart`\n```dart\nclass SettingsScreen extends StatefulWidget {\n  final ISettingsService settingsService;\n  final IStorageService storageService;\n\n  SettingsScreen({\n    super.key,\n    ISettingsService? settingsService,\n    IStorageService? storageService,\n  }) : settingsService = settingsService ?? SettingsServiceImpl(),\n       storageService = storageService ?? StorageServiceImpl();\n\n  @override\n  State<SettingsScreen> createState() => _SettingsScreenState();\n}\n\nclass _SettingsScreenState extends State<SettingsScreen> {\n  int _defaultBpm = 120;\n  bool _debugMode = false;\n  int _classifierLevel = 1;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadSettings();\n  }\n\n  Future<void> _loadSettings() async {\n    await widget.settingsService.init();\n    final bpm = await widget.settingsService.getBpm();\n    final debug = await widget.settingsService.getDebugMode();\n    final level = await widget.settingsService.getClassifierLevel();\n\n    setState(() {\n      _defaultBpm = bpm;\n      _debugMode = debug;\n      _classifierLevel = level;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Settings'),\n      ),\n      body: ListView(\n        children: [\n          _buildBpmSetting(),\n          Divider(),\n          _buildDebugModeSetting(),\n          Divider(),\n          _buildClassifierLevelSetting(),\n          Divider(),\n          _buildRecalibrateSetting(),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildClassifierLevelSetting() {\n    return SwitchListTile(\n      title: Text('Advanced Mode'),\n      subtitle: Text(\n        _classifierLevel == 1\n            ? 'Beginner (3 categories: KICK, SNARE, HIHAT)'\n            : 'Advanced (6 categories with subcategories)',\n      ),\n      value: _classifierLevel == 2,\n      onChanged: (value) async {\n        final newLevel = value ? 2 : 1;\n\n        // Show recalibration warning\n        final confirmed = await showDialog<bool>(\n          context: context,\n          builder: (context) => AlertDialog(\n            title: Text('Recalibration Required'),\n            content: Text(\n              'Switching classifier levels requires recalibration. '\n              'Your current calibration will be cleared.',\n            ),\n            actions: [\n              TextButton(\n                onPressed: () => Navigator.of(context).pop(false),\n                child: Text('Cancel'),\n              ),\n              TextButton(\n                onPressed: () => Navigator.of(context).pop(true),\n                child: Text('Recalibrate'),\n              ),\n            ],\n          ),\n        );\n\n        if (confirmed == true) {\n          await widget.settingsService.setClassifierLevel(newLevel);\n          await widget.storageService.clearCalibration();\n\n          setState(() => _classifierLevel = newLevel);\n\n          if (mounted) {\n            context.go('/calibration');\n          }\n        }\n      },\n    );\n  }\n\n  Widget _buildRecalibrateSetting() {\n    return ListTile(\n      leading: Icon(Icons.refresh),\n      title: Text('Recalibrate'),\n      subtitle: Text('Clear calibration and start over'),\n      trailing: Icon(Icons.arrow_forward),\n      onTap: () async {\n        final confirmed = await showDialog<bool>(\n          context: context,\n          builder: (context) => AlertDialog(\n            title: Text('Confirm Recalibration'),\n            content: Text('This will clear your current calibration.'),\n            actions: [\n              TextButton(\n                onPressed: () => Navigator.of(context).pop(false),\n                child: Text('Cancel'),\n              ),\n              TextButton(\n                onPressed: () => Navigator.of(context).pop(true),\n                child: Text('Recalibrate'),\n              ),\n            ],\n          ),\n        );\n\n        if (confirmed == true) {\n          await widget.storageService.clearCalibration();\n          if (mounted) {\n            context.go('/calibration');\n          }\n        }\n      },\n    );\n  }\n}\n```\n\n### 5. Classifier Level Selection (Rust)\n\n**Modify**: `rust/src/calibration/state.rs`\n```rust\n#[derive(Clone, serde::Serialize, serde::Deserialize)]\npub struct CalibrationState {\n    pub level: u8,  // NEW: 1 or 2\n    pub kick_threshold: f32,\n    pub snare_threshold: f32,\n    // ... existing thresholds ...\n}\n```\n\n**Modify**: `rust/src/analysis/classifier.rs`\n```rust\nimpl Classifier {\n    pub fn classify(&self, features: &AudioFeatures) -> ClassificationResult {\n        let calibration = self.calibration.read().unwrap();\n\n        match calibration.level {\n            1 => self.classify_level1(features),\n            2 => self.classify_level2(features),\n            _ => unreachable!(\"Invalid calibration level\"),\n        }\n    }\n\n    // Existing Level 1 implementation\n    fn classify_level1(&self, features: &AudioFeatures) -> ClassificationResult {\n        // ... existing 3-category logic ...\n    }\n\n    // NEW: Level 2 implementation\n    fn classify_level2(&self, features: &AudioFeatures) -> ClassificationResult {\n        // 6-category classification with subcategories\n        // Kick, Snare, ClosedHiHat, OpenHiHat, KSnare, Silence\n        // ... implement advanced classification logic ...\n    }\n}\n```\n\n### 6. Test Infrastructure\n\n#### 6.1 Test File Organization\n\n```\ntest/\n├── services/\n│   ├── audio_service_test.dart\n│   ├── storage_service_test.dart         # NEW\n│   ├── settings_service_test.dart        # NEW\n│   ├── debug_service_test.dart           # NEW\n│   └── permission_service_test.dart\n├── ui/\n│   ├── screens/\n│   │   ├── training_screen_test.dart\n│   │   ├── calibration_screen_test.dart\n│   │   ├── settings_screen_test.dart     # NEW\n│   │   ├── onboarding_screen_test.dart   # NEW\n│   │   └── splash_screen_test.dart       # NEW\n│   └── widgets/\n│       ├── debug_overlay_test.dart       # NEW\n│       └── ...\n└── integration/\n    └── calibration_flow_test.dart        # NEW\n```\n\n#### 6.2 Mock Definitions\n\n**File**: `test/mocks.dart`\n```dart\nimport 'package:mocktail/mocktail.dart';\n\n// Service mocks\nclass MockAudioService extends Mock implements IAudioService {}\nclass MockStorageService extends Mock implements IStorageService {}\nclass MockSettingsService extends Mock implements ISettingsService {}\nclass MockDebugService extends Mock implements IDebugService {}\nclass MockPermissionService extends Mock implements IPermissionService {}\n```\n\n#### 6.3 Example Test: Storage Service\n\n**File**: `test/services/storage_service_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:mocktail/mocktail.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\nvoid main() {\n  group('StorageServiceImpl', () {\n    late StorageServiceImpl storageService;\n\n    setUp(() async {\n      SharedPreferences.setMockInitialValues({});\n      storageService = StorageServiceImpl();\n      await storageService.init();\n    });\n\n    test('hasCalibration returns false when no data saved', () async {\n      final result = await storageService.hasCalibration();\n      expect(result, isFalse);\n    });\n\n    test('saveCalibration and loadCalibration round-trip', () async {\n      final data = CalibrationData(\n        level: 1,\n        timestamp: DateTime.now(),\n        thresholds: {'kick': 0.5, 'snare': 0.6},\n      );\n\n      await storageService.saveCalibration(data);\n\n      final loaded = await storageService.loadCalibration();\n      expect(loaded, isNotNull);\n      expect(loaded!.level, equals(1));\n      expect(loaded.thresholds['kick'], equals(0.5));\n    });\n\n    test('clearCalibration removes saved data', () async {\n      final data = CalibrationData(level: 1, /* ... */);\n      await storageService.saveCalibration(data);\n\n      await storageService.clearCalibration();\n\n      final hasData = await storageService.hasCalibration();\n      expect(hasData, isFalse);\n    });\n  });\n}\n```\n\n#### 6.4 Coverage Configuration\n\n**File**: `coverage.sh` (update existing script)\n```bash\n#!/bin/bash\nflutter test --coverage\nlcov --remove coverage/lcov.info \\\n  '*/frb_generated.dart' \\\n  '*/bridge_generated.rs' \\\n  '**/*.g.dart' \\\n  -o coverage/lcov_filtered.info\n\ngenhtml coverage/lcov_filtered.info -o coverage/html\n\n# Check coverage threshold\nCOVERAGE=$(lcov --summary coverage/lcov_filtered.info | grep lines | awk '{print $2}' | sed 's/%//')\nTHRESHOLD=80\n\nif (( $(echo \"$COVERAGE < $THRESHOLD\" | bc -l) )); then\n  echo \"ERROR: Coverage $COVERAGE% is below threshold $THRESHOLD%\"\n  exit 1\nelse\n  echo \"SUCCESS: Coverage $COVERAGE% meets threshold $THRESHOLD%\"\nfi\n```\n\n### 7. UAT Test Documentation\n\n**File**: `.spec-workflow/specs/uat-readiness/UAT_TEST_SCENARIOS.md` (to be created in tasks phase)\n\n**Structure**:\n```markdown\n# UAT Test Scenarios for Beatbox Trainer\n\n## Test Environment\n- Devices: Pixel 9a, Samsung Galaxy S21, OnePlus 9\n- Android versions: 11, 12, 13\n- Build: Debug APK from `flutter build apk --debug`\n\n## Scenario 1: First-Time User Onboarding\n**Prerequisite**: Fresh app install, no calibration data\n**Steps**:\n1. Launch app\n2. Verify splash screen appears\n3. Verify onboarding screen displays with 3 calibration steps\n4. Tap \"Start Calibration\"\n5. Complete KICK calibration (10 samples)\n6. Complete SNARE calibration (10 samples)\n7. Complete HIHAT calibration (10 samples)\n8. Verify success message\n9. Verify navigation to training screen\n\n**Expected**: User guided through calibration, data persisted\n**Pass/Fail**: ___\n\n## Scenario 2: Real-Time Classification Feedback\n**Prerequisite**: Calibration complete\n**Steps**:\n1. Tap \"Start\" button\n2. Make KICK sound\n3. Verify sound type displayed with color\n4. Verify timing feedback (ms)\n5. Verify confidence meter\n6. Make SNARE sound\n7. Verify classification updates immediately\n8. Tap \"Stop\"\n\n**Expected**: <100ms latency, accurate classification, smooth animations\n**Pass/Fail**: ___\n\n## [... 13 more scenarios ...]\n\n## Performance Benchmarks\n| Metric | Target | Actual | Pass/Fail |\n|--------|--------|--------|-----------|\n| Audio callback latency (P99) | <10ms | ___ | ___ |\n| UI update latency | <100ms | ___ | ___ |\n| App launch time | <3s | ___ | ___ |\n| Memory usage (training) | <150MB | ___ | ___ |\n| CPU usage (sustained) | <40% | ___ | ___ |\n\n## Sign-Off\n- [ ] All scenarios passed on Pixel 9a\n- [ ] All scenarios passed on Samsung Galaxy S21\n- [ ] All scenarios passed on OnePlus 9\n- [ ] Performance benchmarks met\n- [ ] No critical bugs identified\n\n**QA Engineer**: ___________  **Date**: ___________\n```\n\n## Technology Stack\n\n### New Dependencies\n\n**pubspec.yaml additions**:\n```yaml\ndependencies:\n  go_router: ^14.6.2           # Navigation\n  shared_preferences: ^2.3.4   # Key-value storage\n  fl_chart: ^0.70.4            # Debug charts (optional)\n\ndev_dependencies:\n  mocktail: ^1.0.4             # Mocking (already present)\n  integration_test:             # Integration tests\n    sdk: flutter\n```\n\n**Cargo.toml additions** (if needed):\n```toml\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n```\n\n## Data Models\n\n### CalibrationData (Dart)\n```dart\nclass CalibrationData {\n  final int level;\n  final DateTime timestamp;\n  final Map<String, double> thresholds;\n\n  CalibrationData({\n    required this.level,\n    required this.timestamp,\n    required this.thresholds,\n  });\n\n  factory CalibrationData.fromJson(Map<String, dynamic> json) { /* ... */ }\n  Map<String, dynamic> toJson() { /* ... */ }\n}\n```\n\n### CalibrationState (Rust)\n```rust\n#[derive(Clone, serde::Serialize, serde::Deserialize)]\npub struct CalibrationState {\n    pub level: u8,\n    pub kick_threshold: f32,\n    pub snare_threshold: f32,\n    pub hihat_threshold: f32,\n    // Level 2 additional thresholds\n    pub closed_hihat_threshold: f32,\n    pub open_hihat_threshold: f32,\n    pub ksnare_threshold: f32,\n}\n```\n\n## Performance Considerations\n\n### Optimization Strategies\n\n1. **Stream Buffering**: Prevent UI jank from rapid classification updates\n   ```dart\n   _classificationStream\n       .transform(StreamTransformer.fromHandlers(\n         handleData: (data, sink) {\n           // Throttle updates to 60fps max\n           if (_lastUpdateTime == null ||\n               DateTime.now().difference(_lastUpdateTime!) >\n                   Duration(milliseconds: 16)) {\n             sink.add(data);\n             _lastUpdateTime = DateTime.now();\n           }\n         },\n       ))\n   ```\n\n2. **Debug Mode Performance**: Only subscribe to debug streams when enabled\n   ```dart\n   Stream<AudioMetrics>? _debugStream;\n\n   void _toggleDebugMode(bool enabled) {\n     if (enabled) {\n       _debugStream = debugService.getAudioMetricsStream();\n     } else {\n       _debugStream = null;  // Unsubscribe\n     }\n   }\n   ```\n\n3. **Lazy Initialization**: Defer service initialization until needed\n   ```dart\n   late final IDebugService _debugService = DebugServiceImpl();  // Lazy\n   ```\n\n## Error Handling\n\n### New Error Types\n\n**CalibrationServiceException**:\n```dart\nclass CalibrationServiceException implements Exception {\n  final String message;\n  final CalibrationError? rustError;\n\n  CalibrationServiceException(this.message, [this.rustError]);\n}\n```\n\n**StorageException**:\n```dart\nclass StorageException implements Exception {\n  final String message;\n  final Exception? cause;\n\n  StorageException(this.message, [this.cause]);\n}\n```\n\n## Security Considerations\n\n1. **Calibration Data Validation**: Verify thresholds are within valid ranges before loading\n2. **Settings Sanitization**: Validate all settings values before saving\n3. **Debug Mode Protection**: Ensure debug logs don't leak sensitive data\n4. **Storage Encryption**: Consider encrypting calibration data if user privacy is concern (out of scope for UAT)\n\n## Accessibility\n\n1. **Screen Reader Support**: Add semantic labels to all interactive elements\n2. **Large Text Support**: Ensure UI scales with system font size\n3. **Color Blind Mode**: Use patterns in addition to colors for feedback\n4. **Haptic Feedback**: Add vibration feedback for successful classifications (optional)\n\n## Internationalization (Future)\n\nCurrently English-only, but design supports future i18n:\n- All user-facing strings in separate constants file\n- Date/time formatting locale-aware\n- Numeric formatting locale-aware\n\n## Migration Strategy\n\n### Gradual Rollout Plan\n\n1. **Phase 1**: Calibration onboarding (1 week)\n   - Splash screen + onboarding + storage service\n   - Prevents breaking existing users\n\n2. **Phase 2**: Real-time feedback enhancements (3 days)\n   - Confidence scores + animations\n   - Backward compatible with existing calibration\n\n3. **Phase 3**: Debug mode + Settings (1 week)\n   - Optional features, no impact on core flow\n\n4. **Phase 4**: Classifier Level 2 (1 week)\n   - Advanced users opt-in via settings\n\n5. **Phase 5**: Testing infrastructure (1 week)\n   - Unit tests + integration tests + coverage\n\n6. **Phase 6**: UAT documentation + execution (3 days)\n   - Test scenario execution + sign-off\n\n## Success Criteria\n\n1. ✅ All 6 user stories implemented and tested\n2. ✅ Zero critical bugs (no crashes, hangs, data loss)\n3. ✅ 80%+ test coverage (90%+ on critical paths)\n4. ✅ All UAT scenarios pass on 3 devices\n5. ✅ Performance NFRs met on Pixel 9a\n6. ✅ Documentation complete (README, UAT scenarios, API docs)\n\n## Open Questions\n\n1. **Calibration expiry**: Should calibration data expire after X days?\n2. **Cloud backup**: Should calibration sync across devices? (Out of scope for UAT)\n3. **Analytics**: Track calibration success rates? (Privacy considerations)\n4. **Audio recording**: Allow users to record training sessions? (Storage implications)\n\n## References\n\n- [Flutter go_router documentation](https://pub.dev/packages/go_router)\n- [shared_preferences best practices](https://pub.dev/packages/shared_preferences)\n- [Mocktail testing patterns](https://pub.dev/packages/mocktail)\n- [Flutter testing documentation](https://docs.flutter.dev/testing)\n",
  "fileStats": {
    "size": 38802,
    "lines": 1216,
    "lastModified": "2025-11-13T12:28:56.840Z"
  },
  "comments": []
}