{
  "id": "snapshot_1763124639450_se1rsl55y",
  "approvalId": "approval_1763124639445_k2hb17rzp",
  "approvalTitle": "Calibration Workflow Tasks Document",
  "version": 1,
  "timestamp": "2025-11-14T12:50:39.450Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Calibration Workflow Fix - Tasks\n\n## Task Hierarchy\n\nThis document breaks down the implementation into atomic, testable tasks following the design document.\n\n### Status Legend\n- `[ ]` - Pending\n- `[-]` - In Progress\n- `[x]` - Completed\n\n---\n\n## Phase 1: CalibrationManager Enhancement\n\n### Task 1.1: Add get_procedure_arc() method to CalibrationManager\n**Status:** `[ ]`\n\n**Description:**\nAdd a public method to expose the calibration procedure reference for sharing with the audio engine.\n\n**Files Modified:**\n- `rust/src/managers/calibration_manager.rs`\n\n**Implementation:**\n```rust\nimpl CalibrationManager {\n    /// Get Arc reference to calibration procedure for sharing with audio engine\n    ///\n    /// # Returns\n    /// `Arc<Mutex<Option<CalibrationProcedure>>>` - Thread-safe reference to procedure\n    pub fn get_procedure_arc(&self) -> Arc<Mutex<Option<CalibrationProcedure>>> {\n        Arc::clone(&self.procedure)\n    }\n}\n```\n\n**Unit Tests:**\n```rust\n#[test]\nfn test_get_procedure_arc() {\n    let manager = CalibrationManager::new();\n    let (broadcast_tx, _) = broadcast::channel(100);\n\n    manager.start(broadcast_tx).unwrap();\n\n    let procedure_arc = manager.get_procedure_arc();\n    let procedure_guard = procedure_arc.lock().unwrap();\n    assert!(procedure_guard.is_some());\n}\n\n#[test]\nfn test_get_procedure_arc_when_not_started() {\n    let manager = CalibrationManager::new();\n\n    let procedure_arc = manager.get_procedure_arc();\n    let procedure_guard = procedure_arc.lock().unwrap();\n    assert!(procedure_guard.is_none());\n}\n```\n\n**Acceptance Criteria:**\n- ✓ Method returns Arc<Mutex<Option<CalibrationProcedure>>>\n- ✓ Arc can be cloned and shared across threads\n- ✓ Returns Some when calibration is active\n- ✓ Returns None when calibration is not active\n- ✓ Unit tests pass\n\n**Time Estimate:** 30 minutes\n\n---\n\n## Phase 2: Analysis Thread Modifications\n\n### Task 2.1: Update spawn_analysis_thread() signature\n**Status:** `[ ]`\n\n**Description:**\nAdd `calibration_procedure` and `calibration_progress_tx` parameters to the analysis thread spawning function.\n\n**Files Modified:**\n- `rust/src/analysis/mod.rs`\n\n**Implementation:**\n```rust\npub fn spawn_analysis_thread(\n    mut analysis_channels: AnalysisThreadChannels,\n    calibration_state: Arc<RwLock<CalibrationState>>,     // Renamed from 'calibration'\n    calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>, // NEW\n    calibration_progress_tx: Option<broadcast::Sender<CalibrationProgress>>, // NEW\n    frame_counter: Arc<AtomicU64>,\n    bpm: Arc<AtomicU32>,\n    sample_rate: u32,\n    result_sender: tokio::sync::broadcast::Sender<ClassificationResult>,\n) -> JoinHandle<()>\n```\n\n**Acceptance Criteria:**\n- ✓ Function signature updated with new parameters\n- ✓ Existing parameter renamed for clarity (calibration → calibration_state)\n- ✓ Compiles successfully (even if not used yet)\n- ✓ Documentation updated\n\n**Time Estimate:** 15 minutes\n\n---\n\n### Task 2.2: Implement calibration mode logic in analysis thread\n**Status:** `[ ]`\n\n**Description:**\nAdd logic to check calibration state and forward features to calibration procedure during calibration mode.\n\n**Files Modified:**\n- `rust/src/analysis/mod.rs`\n\n**Implementation:**\nReplace lines 104-146 in the main analysis loop:\n\n```rust\n// For each detected onset, run pipeline\nfor onset_timestamp in onsets {\n    let onset_idx = (onset_timestamp % buffer.len() as u64) as usize;\n\n    if onset_idx + 1024 <= buffer.len() {\n        let onset_window = &buffer[onset_idx..onset_idx + 1024];\n        let features = feature_extractor.extract(onset_window);\n\n        // Check if calibration is active\n        let calibration_active = if let Ok(procedure_guard) = calibration_procedure.try_lock() {\n            procedure_guard.is_some()\n        } else {\n            false // Lock failed, assume not calibrating\n        };\n\n        if calibration_active {\n            // ====== CALIBRATION MODE ======\n            if let Ok(mut procedure_guard) = calibration_procedure.lock() {\n                if let Some(ref mut procedure) = *procedure_guard {\n                    match procedure.add_sample(features) {\n                        Ok(()) => {\n                            let progress = procedure.get_progress();\n                            if let Some(ref tx) = calibration_progress_tx {\n                                let _ = tx.send(progress);\n                            }\n                        }\n                        Err(err) => {\n                            eprintln!(\"Calibration sample rejected: {:?}\", err);\n                        }\n                    }\n                }\n            }\n        } else {\n            // ====== CLASSIFICATION MODE (existing logic) ======\n            let (sound, confidence) = classifier.classify_level1(&features);\n\n            let current_bpm = bpm.load(std::sync::atomic::Ordering::Relaxed);\n            let timing = if current_bpm > 0 {\n                quantizer.quantize(onset_timestamp)\n            } else {\n                TimingFeedback {\n                    classification: quantizer::TimingClassification::OnTime,\n                    error_ms: 0.0,\n                }\n            };\n\n            let timestamp_ms = (onset_timestamp as f64 / sample_rate as f64 * 1000.0) as u64;\n\n            let result = ClassificationResult {\n                sound,\n                timing,\n                timestamp_ms,\n                confidence,\n            };\n\n            let _ = result_sender.send(result);\n        }\n    }\n}\n```\n\n**Acceptance Criteria:**\n- ✓ Calibration mode check uses try_lock() (non-blocking)\n- ✓ Features forwarded to procedure during calibration\n- ✓ Progress broadcast after successful sample\n- ✓ Errors logged but don't crash thread\n- ✓ Classification mode works when calibration is inactive\n- ✓ Code compiles and links\n\n**Time Estimate:** 1 hour\n\n---\n\n### Task 2.3: Add unit tests for analysis thread calibration mode\n**Status:** `[ ]`\n\n**Description:**\nCreate comprehensive unit tests for the calibration mode logic in the analysis thread.\n\n**Files Modified:**\n- `rust/src/analysis/mod.rs` (add test module)\n\n**Test Cases:**\n\n#### Test 1: Calibration mode forwards features to procedure\n```rust\n#[test]\nfn test_calibration_mode_forwards_to_procedure() {\n    // Setup: Create mock procedure with Arc<Mutex<Option<>>>\n    let procedure = Arc::new(Mutex::new(Some(CalibrationProcedure::new_default())));\n    let (progress_tx, mut progress_rx) = broadcast::channel(10);\n\n    // Create synthetic audio with onset\n    let buffer = create_test_buffer_with_onset();\n\n    // Feed to analysis thread components\n    let mut onset_detector = OnsetDetector::new(48000);\n    let feature_extractor = FeatureExtractor::new(48000);\n\n    let onsets = onset_detector.process(&buffer);\n    assert!(!onsets.is_empty());\n\n    // Process onset with calibration active\n    for onset_timestamp in onsets {\n        let onset_idx = (onset_timestamp % buffer.len() as u64) as usize;\n        if onset_idx + 1024 <= buffer.len() {\n            let features = feature_extractor.extract(&buffer[onset_idx..onset_idx + 1024]);\n\n            // Simulate calibration mode logic\n            if let Ok(mut proc_guard) = procedure.lock() {\n                if let Some(ref mut proc) = *proc_guard {\n                    proc.add_sample(features).unwrap();\n                    let progress = proc.get_progress();\n                    let _ = progress_tx.send(progress);\n                }\n            }\n        }\n    }\n\n    // Assert: Sample was added to procedure\n    let proc_guard = procedure.lock().unwrap();\n    assert_eq!(proc_guard.as_ref().unwrap().get_progress().samples_collected, 1);\n\n    // Assert: Progress was broadcast\n    let progress = progress_rx.try_recv().unwrap();\n    assert_eq!(progress.samples_collected, 1);\n}\n```\n\n#### Test 2: Classification mode when procedure is None\n```rust\n#[test]\nfn test_classification_mode_when_procedure_is_none() {\n    // Setup: procedure = None\n    let procedure = Arc::new(Mutex::new(None));\n    let (result_tx, mut result_rx) = broadcast::channel(10);\n\n    // Create test components\n    let calibration_state = Arc::new(RwLock::new(CalibrationState::new_default()));\n    let classifier = Classifier::new(Arc::clone(&calibration_state));\n    let feature_extractor = FeatureExtractor::new(48000);\n\n    // Create synthetic features\n    let buffer = create_test_buffer_with_onset();\n    let features = feature_extractor.extract(&buffer[0..1024]);\n\n    // Process in classification mode\n    let calibration_active = {\n        let guard = procedure.lock().unwrap();\n        guard.is_some()\n    };\n\n    assert!(!calibration_active);\n\n    // Classify\n    let (sound, confidence) = classifier.classify_level1(&features);\n    let result = ClassificationResult {\n        sound,\n        timing: TimingFeedback { classification: quantizer::TimingClassification::OnTime, error_ms: 0.0 },\n        timestamp_ms: 0,\n        confidence,\n    };\n    let _ = result_tx.send(result);\n\n    // Assert: ClassificationResult was broadcast\n    let received = result_rx.try_recv().unwrap();\n    assert!(received.confidence > 0.0);\n}\n```\n\n#### Test 3: Invalid features rejected gracefully\n```rust\n#[test]\nfn test_invalid_features_rejected_gracefully() {\n    // Setup: procedure that will reject samples\n    let procedure = Arc::new(Mutex::new(Some(CalibrationProcedure::new_default())));\n    let (progress_tx, mut progress_rx) = broadcast::channel(10);\n\n    // Create invalid features (out of range)\n    let invalid_features = Features {\n        centroid: 30.0,  // Too low (< 50 Hz)\n        zcr: 0.05,\n        flatness: 0.5,\n        rolloff: 5000.0,\n        decay_time_ms: 50.0,\n    };\n\n    // Try to add sample\n    let result = {\n        let mut proc_guard = procedure.lock().unwrap();\n        proc_guard.as_mut().unwrap().add_sample(invalid_features)\n    };\n\n    // Assert: Sample was rejected\n    assert!(result.is_err());\n\n    // Assert: Thread would continue (no panic)\n    // Assert: No progress broadcast\n    assert!(progress_rx.try_recv().is_err());\n}\n```\n\n#### Test 4: Progress broadcast after each sample\n```rust\n#[test]\nfn test_progress_broadcast_after_each_sample() {\n    let procedure = Arc::new(Mutex::new(Some(CalibrationProcedure::new_default())));\n    let (progress_tx, mut progress_rx) = broadcast::channel(10);\n\n    let valid_features = Features {\n        centroid: 1000.0,\n        zcr: 0.05,\n        flatness: 0.5,\n        rolloff: 5000.0,\n        decay_time_ms: 50.0,\n    };\n\n    // Add 3 samples\n    for _ in 0..3 {\n        let mut proc_guard = procedure.lock().unwrap();\n        proc_guard.as_mut().unwrap().add_sample(valid_features).unwrap();\n        let progress = proc_guard.as_ref().unwrap().get_progress();\n        let _ = progress_tx.send(progress);\n    }\n\n    // Assert: 3 progress messages broadcast\n    let mut count = 0;\n    while let Ok(_) = progress_rx.try_recv() {\n        count += 1;\n    }\n    assert_eq!(count, 3);\n}\n```\n\n#### Test 5: Lock failure fallback to classification\n```rust\n#[test]\nfn test_lock_failure_fallback_to_classification() {\n    // This test simulates what happens if try_lock() fails\n    // In practice, this is rare, but we should handle it gracefully\n\n    let procedure = Arc::new(Mutex::new(Some(CalibrationProcedure::new_default())));\n\n    // Hold the lock to simulate contention\n    let _guard = procedure.lock().unwrap();\n\n    // Try to check calibration state with try_lock()\n    let calibration_active = if let Ok(proc_guard) = procedure.try_lock() {\n        proc_guard.is_some()\n    } else {\n        false // Lock failed, fallback\n    };\n\n    // Assert: Falls back to classification mode\n    assert!(!calibration_active);\n}\n```\n\n**Test Helper Functions:**\n```rust\n#[cfg(test)]\nmod test_helpers {\n    use super::*;\n\n    /// Create a test audio buffer with synthetic onset at frame 1000\n    pub fn create_test_buffer_with_onset() -> Vec<f32> {\n        let mut buffer = vec![0.0; 4800]; // 100ms @ 48kHz\n\n        // Add transient at frame 1000\n        for i in 1000..1200 {\n            let t = (i - 1000) as f32 / 200.0;\n            buffer[i] = (1.0 - t) * 0.8 * (t * 10.0).sin();\n        }\n\n        buffer\n    }\n}\n```\n\n**Acceptance Criteria:**\n- ✓ All 5 test cases pass\n- ✓ Test coverage ≥ 90% for modified code\n- ✓ Tests use mock/synthetic data (no real audio files)\n- ✓ Tests run in < 1 second total\n\n**Time Estimate:** 2 hours\n\n---\n\n## Phase 3: AudioEngine Integration\n\n### Task 3.1: Update AudioEngine::start() signature\n**Status:** `[ ]`\n\n**Description:**\nModify the `start()` method to accept calibration procedure and progress broadcast channel.\n\n**Files Modified:**\n- `rust/src/audio/engine.rs`\n\n**Implementation:**\n```rust\npub fn start(\n    &mut self,\n    calibration_state: Arc<RwLock<CalibrationState>>,  // Renamed for clarity\n    calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>,  // NEW\n    calibration_progress_tx: Option<broadcast::Sender<CalibrationProgress>>, // NEW\n    result_sender: broadcast::Sender<ClassificationResult>,\n) -> Result<(), AudioError>\n```\n\n**Acceptance Criteria:**\n- ✓ Signature updated with new parameters\n- ✓ Documentation updated\n- ✓ Compiles successfully\n\n**Time Estimate:** 15 minutes\n\n---\n\n### Task 3.2: Update spawn_analysis_thread_internal()\n**Status:** `[ ]`\n\n**Description:**\nPass calibration procedure and progress channel to the analysis thread.\n\n**Files Modified:**\n- `rust/src/audio/engine.rs`\n\n**Implementation:**\n```rust\nfn spawn_analysis_thread_internal(\n    &self,\n    buffer_channels: BufferPoolChannels,\n    calibration_state: Arc<RwLock<CalibrationState>>,\n    calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>,  // NEW\n    calibration_progress_tx: Option<broadcast::Sender<CalibrationProgress>>, // NEW\n    result_sender: broadcast::Sender<ClassificationResult>,\n) {\n    let (_, analysis_channels) = buffer_channels.split_for_threads();\n\n    let frame_counter_clone = Arc::clone(&self.frame_counter);\n    let bpm_clone = Arc::clone(&self.bpm);\n\n    crate::analysis::spawn_analysis_thread(\n        analysis_channels,\n        calibration_state,\n        calibration_procedure,          // NEW\n        calibration_progress_tx,        // NEW\n        frame_counter_clone,\n        bpm_clone,\n        self.sample_rate,\n        result_sender,\n    );\n}\n```\n\n**Update start() method body:**\n```rust\npub fn start(\n    &mut self,\n    calibration_state: Arc<RwLock<CalibrationState>>,\n    calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>,\n    calibration_progress_tx: Option<broadcast::Sender<CalibrationProgress>>,\n    result_sender: broadcast::Sender<ClassificationResult>,\n) -> Result<(), AudioError> {\n    // ... stream creation code (unchanged) ...\n\n    // Spawn analysis thread with new parameters\n    self.spawn_analysis_thread_internal(\n        buffer_channels,\n        calibration_state,\n        calibration_procedure,      // NEW\n        calibration_progress_tx,    // NEW\n        result_sender\n    );\n\n    Ok(())\n}\n```\n\n**Acceptance Criteria:**\n- ✓ Parameters passed through to analysis thread\n- ✓ Compiles successfully\n- ✓ No functional changes (behavior unchanged)\n\n**Time Estimate:** 30 minutes\n\n---\n\n### Task 3.3: Add unit tests for AudioEngine parameter passing\n**Status:** `[ ]`\n\n**Description:**\nVerify that AudioEngine correctly passes calibration parameters to analysis thread.\n\n**Files Modified:**\n- `rust/src/audio/engine.rs` (add to existing test module)\n\n**Test Cases:**\n\n```rust\n#[test]\nfn test_audio_engine_start_with_calibration_parameters() {\n    let channels = BufferPool::new(16, DEFAULT_BUFFER_SIZE);\n    let mut engine = AudioEngine::new(120, 48000, channels).unwrap();\n\n    let calibration_state = Arc::new(RwLock::new(CalibrationState::new_default()));\n    let calibration_procedure = Arc::new(Mutex::new(Some(CalibrationProcedure::new_default())));\n    let (progress_tx, _) = broadcast::channel(100);\n    let (result_tx, _) = broadcast::channel(100);\n\n    // Note: On desktop, this uses StubAudioEngine which won't actually start\n    // but it should accept the parameters without error\n    let result = engine.start(\n        calibration_state,\n        calibration_procedure,\n        Some(progress_tx),\n        result_tx,\n    );\n\n    // On Android: should succeed; On desktop: StubAudioEngine returns Ok\n    assert!(result.is_ok() || cfg!(not(target_os = \"android\")));\n}\n```\n\n**Acceptance Criteria:**\n- ✓ Test compiles on all platforms (Android + desktop)\n- ✓ Test passes\n- ✓ Stub implementation works on desktop\n\n**Time Estimate:** 30 minutes\n\n---\n\n## Phase 4: AppContext Integration\n\n### Task 4.1: Modify AudioEngineManager to accept calibration parameters\n**Status:** `[ ]`\n\n**Description:**\nUpdate `AudioEngineManager::start()` to accept and pass calibration parameters to AudioEngine.\n\n**Files Modified:**\n- `rust/src/managers/audio_engine_manager.rs`\n\n**Implementation:**\n```rust\npub fn start(\n    &mut self,\n    calibration_state: Arc<RwLock<CalibrationState>>,\n    calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>,  // NEW\n    calibration_progress_tx: Option<broadcast::Sender<CalibrationProgress>>, // NEW\n    result_sender: broadcast::Sender<ClassificationResult>,\n) -> Result<(), AudioError> {\n    if let Some(ref mut engine) = self.engine {\n        engine.start(\n            calibration_state,\n            calibration_procedure,\n            calibration_progress_tx,\n            result_sender\n        )\n    } else {\n        Err(AudioError::NotInitialized)\n    }\n}\n```\n\n**Acceptance Criteria:**\n- ✓ Parameters passed through to AudioEngine\n- ✓ Compiles successfully\n- ✓ Existing functionality unchanged\n\n**Time Estimate:** 20 minutes\n\n---\n\n### Task 4.2: Update AppContext::start_audio() to pass calibration parameters\n**Status:** `[ ]`\n\n**Description:**\nModify `start_audio()` to retrieve and pass calibration procedure to audio engine.\n\n**Files Modified:**\n- `rust/src/context.rs`\n\n**Implementation:**\n```rust\npub fn start_audio(&self, bpm: u32) -> Result<(), AudioError> {\n    #[cfg(target_os = \"android\")]\n    {\n        // Get calibration references\n        let calibration_state = self.calibration.get_state_arc();\n        let calibration_procedure = self.calibration.get_procedure_arc();  // NEW\n\n        // Get broadcast senders\n        let classification_tx = self.broadcasts.get_classification_sender()\n            .ok_or_else(|| AudioError::HardwareError {\n                details: \"Classification broadcast not initialized\".to_string()\n            })?;\n\n        let calibration_progress_tx = self.broadcasts.get_calibration_sender();  // NEW: Optional\n\n        // Start audio engine with all parameters\n        self.audio.start(\n            calibration_state,\n            calibration_procedure,      // NEW\n            calibration_progress_tx,    // NEW\n            classification_tx\n        )?;\n\n        // Set BPM after starting\n        self.audio.set_bpm(bpm)?;\n    }\n\n    Ok(())\n}\n```\n\n**Acceptance Criteria:**\n- ✓ Calibration procedure retrieved from CalibrationManager\n- ✓ Progress broadcast channel retrieved (if initialized)\n- ✓ Parameters passed to audio engine\n- ✓ Compiles successfully\n\n**Time Estimate:** 30 minutes\n\n---\n\n### Task 4.3: Implement audio restart logic in start_calibration()\n**Status:** `[ ]`\n\n**Description:**\nModify `start_calibration()` to restart the audio engine with calibration procedure active.\n\n**Files Modified:**\n- `rust/src/context.rs`\n\n**Implementation:**\n```rust\npub fn start_calibration(&self) -> Result<(), CalibrationError> {\n    // Initialize calibration procedure\n    let broadcast_tx = self.broadcasts.init_calibration();\n    self.calibration.start(broadcast_tx)?;\n\n    #[cfg(target_os = \"android\")]\n    {\n        // Stop audio engine if running (to restart with calibration procedure)\n        if let Err(err) = self.stop_audio() {\n            // Log warning but don't fail (might not be running)\n            eprintln!(\"Warning: Failed to stop audio engine: {:?}\", err);\n        }\n\n        // Restart audio engine with calibration procedure\n        const DEFAULT_CALIBRATION_BPM: u32 = 120;\n        self.start_audio(DEFAULT_CALIBRATION_BPM)\n            .map_err(|audio_err| CalibrationError::AudioEngineError {\n                details: format!(\"Failed to start audio engine for calibration: {:?}\", audio_err),\n            })?;\n    }\n\n    Ok(())\n}\n```\n\n**Acceptance Criteria:**\n- ✓ Audio engine stops before calibration starts\n- ✓ Audio engine restarts with calibration procedure\n- ✓ Stop errors are logged but don't fail the operation\n- ✓ Start errors propagate as CalibrationError::AudioEngineError\n- ✓ Metronome plays at 120 BPM during calibration\n\n**Time Estimate:** 30 minutes\n\n---\n\n### Task 4.4: Add BroadcastChannelManager::get_calibration_sender() method\n**Status:** `[ ]`\n\n**Description:**\nAdd method to retrieve optional calibration broadcast sender.\n\n**Files Modified:**\n- `rust/src/managers/broadcast_manager.rs`\n\n**Implementation:**\n```rust\nimpl BroadcastChannelManager {\n    /// Get calibration broadcast sender (if initialized)\n    ///\n    /// # Returns\n    /// `Option<broadcast::Sender<CalibrationProgress>>` - Sender if calibration is active\n    pub fn get_calibration_sender(&self) -> Option<broadcast::Sender<CalibrationProgress>> {\n        if let Ok(guard) = self.calibration.read() {\n            guard.clone()\n        } else {\n            None\n        }\n    }\n}\n```\n\n**Unit Test:**\n```rust\n#[test]\nfn test_get_calibration_sender() {\n    let manager = BroadcastChannelManager::new();\n\n    // Before init: returns None\n    assert!(manager.get_calibration_sender().is_none());\n\n    // After init: returns Some\n    let _tx = manager.init_calibration();\n    assert!(manager.get_calibration_sender().is_some());\n}\n```\n\n**Acceptance Criteria:**\n- ✓ Returns None before calibration initialized\n- ✓ Returns Some after init_calibration()\n- ✓ Unit test passes\n\n**Time Estimate:** 20 minutes\n\n---\n\n## Phase 5: Integration Testing\n\n### Task 5.1: Create end-to-end calibration workflow test\n**Status:** `[ ]`\n\n**Description:**\nTest the complete calibration workflow from start to finish with synthetic audio.\n\n**Files Created:**\n- `rust/tests/calibration_integration_test.rs`\n\n**Implementation:**\n```rust\nuse beatbox_trainer::*;\nuse std::sync::{Arc, RwLock, Mutex};\nuse tokio::sync::broadcast;\n\n#[test]\n#[cfg(target_os = \"android\")]\nfn test_full_calibration_workflow() {\n    // 1. Initialize AppContext\n    let app_context = AppContext::new().expect(\"Failed to create AppContext\");\n\n    // 2. Start calibration\n    app_context.start_calibration().expect(\"Failed to start calibration\");\n\n    // 3. Subscribe to progress updates\n    let (_, mut progress_rx) = broadcast::channel::<CalibrationProgress>(100);\n    // Note: In real scenario, this would be connected via FFI stream\n\n    // 4. Feed synthetic audio with 30 beatbox sounds\n    // This would require:\n    // - Creating synthetic kick/snare/hihat audio buffers\n    // - Feeding them through the audio engine's buffer pool\n    // - Simulating audio callback processing\n\n    // For initial implementation, we'll test the workflow without actual audio:\n    // - Verify calibration procedure is initialized\n    // - Verify audio engine is running\n    // - Manual testing will verify actual audio processing\n\n    let procedure_arc = app_context.calibration.get_procedure_arc();\n    let procedure_guard = procedure_arc.lock().unwrap();\n    assert!(procedure_guard.is_some(), \"Calibration procedure should be initialized\");\n\n    // 5. In manual testing, user would perform 30 sounds here\n\n    // 6. Finish calibration (would fail here because no samples collected)\n    // In real test, we'd add samples first\n\n    // 7. Stop audio engine\n    app_context.stop_audio().expect(\"Failed to stop audio engine\");\n}\n\n#[test]\n#[cfg(target_os = \"android\")]\nfn test_calibration_with_invalid_samples() {\n    // Similar structure to above, but:\n    // - Feed mix of valid and invalid samples\n    // - Verify only valid samples accepted\n    // - Verify progress reflects correct count\n\n    // This requires ability to inject test samples into analysis thread\n    // Will be implemented after core workflow is working\n}\n\n#[test]\nfn test_calibration_restart_audio() {\n    // Test that audio engine restarts cleanly during calibration start\n\n    let app_context = AppContext::new().expect(\"Failed to create AppContext\");\n\n    // Start audio in classification mode\n    app_context.start_audio(120).ok();\n\n    // Start calibration (should restart audio)\n    let start_time = std::time::Instant::now();\n    app_context.start_calibration().expect(\"Failed to start calibration\");\n    let elapsed = start_time.elapsed();\n\n    // Verify restart happens quickly (< 200ms)\n    assert!(elapsed.as_millis() < 200, \"Audio restart took too long: {:?}\", elapsed);\n\n    // Clean up\n    app_context.stop_audio().ok();\n}\n```\n\n**Note on Integration Testing:**\nFull end-to-end testing with actual audio processing requires:\n1. Test fixtures for synthetic audio\n2. Ability to inject audio into the engine's buffer pool\n3. Mechanism to wait for analysis thread processing\n\nFor initial implementation, we'll rely on:\n- Unit tests for individual components\n- Manual testing with real audio on Android device\n- Future enhancement: Full integration test with synthetic audio injection\n\n**Acceptance Criteria:**\n- ✓ Calibration procedure initializes correctly\n- ✓ Audio engine restarts within 200ms\n- ✓ Tests compile on Android and desktop\n- ✓ Desktop tests use stub implementations\n\n**Time Estimate:** 2 hours\n\n---\n\n### Task 5.2: Manual testing on Android device\n**Status:** `[ ]`\n\n**Description:**\nDeploy to Android device and perform manual calibration workflow testing.\n\n**Test Procedure:**\n\n1. **Setup:**\n   - Build and deploy app to Android device\n   - Grant microphone permissions\n   - Ensure quiet environment (< 40dB ambient noise)\n\n2. **Test Case 1: Complete Calibration Workflow**\n   - Tap \"Calibrate\" button\n   - Verify UI shows \"Perform KICK sound: 0/10\"\n   - Perform 10 kick drum sounds (~2 seconds apart)\n   - Verify progress updates in real-time (0/10 → 1/10 → ... → 10/10)\n   - Verify UI transitions to \"Perform SNARE sound: 0/10\"\n   - Perform 10 snare sounds\n   - Verify progress updates\n   - Verify UI transitions to \"Perform HI-HAT sound: 0/10\"\n   - Perform 10 hi-hat sounds\n   - Verify completion message: \"Calibration complete!\"\n   - Verify calibration state saved (close and reopen app, check state)\n\n3. **Test Case 2: Invalid Samples**\n   - Start calibration\n   - Perform very quiet sounds (should be rejected)\n   - Perform non-beatbox sounds (talking, clapping)\n   - Verify invalid samples don't increment progress\n   - Verify valid samples do increment progress\n\n4. **Test Case 3: Audio Restart Latency**\n   - Start calibration\n   - Listen for audio gap when metronome restarts\n   - Verify gap is brief (< 200ms, barely noticeable)\n   - Verify metronome resumes at 120 BPM\n\n5. **Test Case 4: Calibration Cancellation**\n   - Start calibration\n   - Collect 5 kick samples\n   - Close app (kill process)\n   - Reopen app\n   - Verify calibration state is not saved (incomplete)\n   - Verify app doesn't crash\n\n6. **Test Case 5: Error Handling**\n   - Start calibration without microphone permission → Verify error message\n   - Start calibration twice → Verify \"already in progress\" error\n\n**Log Analysis:**\nCheck device logs for:\n- Onset detection events: `Onset detected at frame X`\n- Sample acceptance: `Calibration sample accepted: KICK (5/10)`\n- Sample rejection: `Calibration sample rejected: Centroid out of range`\n- Progress broadcasts: `Progress broadcast: KICK 5/10`\n\n**Acceptance Criteria:**\n- ✓ Complete calibration workflow succeeds (30 samples)\n- ✓ Progress updates visible in UI in real-time\n- ✓ Invalid samples rejected silently\n- ✓ Audio restart gap < 200ms (barely noticeable)\n- ✓ Calibration state persists after completion\n- ✓ No crashes or panics observed\n\n**Time Estimate:** 1.5 hours\n\n---\n\n## Phase 6: Documentation and Cleanup\n\n### Task 6.1: Update API documentation\n**Status:** `[ ]`\n\n**Description:**\nUpdate inline documentation for all modified functions.\n\n**Files Modified:**\n- `rust/src/analysis/mod.rs`\n- `rust/src/audio/engine.rs`\n- `rust/src/context.rs`\n- `rust/src/managers/audio_engine_manager.rs`\n- `rust/src/managers/calibration_manager.rs`\n- `rust/src/managers/broadcast_manager.rs`\n\n**Documentation Requirements:**\n- Function-level doc comments with `///`\n- Parameter descriptions with `# Arguments`\n- Return value descriptions with `# Returns`\n- Error cases with `# Errors`\n- Examples where appropriate with `# Example`\n- Thread safety notes with `# Thread Safety`\n\n**Acceptance Criteria:**\n- ✓ All public functions have doc comments\n- ✓ All parameters documented\n- ✓ `cargo doc` builds without warnings\n- ✓ Generated docs are clear and accurate\n\n**Time Estimate:** 1 hour\n\n---\n\n### Task 6.2: Update CHANGELOG.md\n**Status:** `[ ]`\n\n**Description:**\nDocument the calibration workflow fix in the project changelog.\n\n**Files Modified:**\n- `CHANGELOG.md` (if exists, otherwise create)\n\n**Entry Format:**\n```markdown\n## [Unreleased]\n\n### Added\n- Calibration workflow now sends real-time progress updates to UI\n- Analysis thread supports calibration mode (forwards onset features to calibration procedure)\n- AudioEngine accepts calibration procedure reference for sample collection\n\n### Changed\n- `spawn_analysis_thread()` signature now includes calibration procedure and progress channel\n- `AudioEngine::start()` signature now includes calibration parameters\n- `start_calibration()` now restarts audio engine to activate calibration mode\n\n### Fixed\n- Calibration UI no longer shows \"waiting for calibration data\" indefinitely\n- Onset detection events now properly forwarded to calibration procedure\n- Calibration progress updates now broadcast in real-time (< 100ms latency)\n\n### Technical Details\n- Added calibration mode logic to analysis thread main loop\n- Implemented non-blocking lock check for calibration state\n- Audio engine restart latency < 200ms during calibration start\n```\n\n**Acceptance Criteria:**\n- ✓ CHANGELOG updated with user-facing changes\n- ✓ Technical details included for developers\n- ✓ Follows semantic versioning conventions\n\n**Time Estimate:** 20 minutes\n\n---\n\n### Task 6.3: Code review and quality audit\n**Status:** `[ ]`\n\n**Description:**\nPerform self-review of all changes against project quality standards.\n\n**Checklist:**\n\n#### Code Quality (from CLAUDE.md)\n- [ ] All files < 500 lines (excluding comments/blank lines)\n- [ ] All functions < 50 lines\n- [ ] SOLID principles followed (Single Responsibility, Dependency Injection)\n- [ ] No testability blockers (no globals, mockable dependencies)\n- [ ] Error handling: Fail fast with structured logging\n- [ ] No secrets or PII in logs\n\n#### Architecture\n- [ ] Lock-free audio callback (no mutexes, no allocations)\n- [ ] Real-time safety maintained\n- [ ] Dependency injection used throughout\n- [ ] Clear separation of concerns\n\n#### Testing\n- [ ] Unit test coverage ≥ 90% for modified code\n- [ ] Integration tests cover end-to-end workflow\n- [ ] Edge cases tested (lock failure, invalid samples, etc.)\n- [ ] Tests run in < 5 seconds total\n\n#### Documentation\n- [ ] All public functions documented\n- [ ] Complex logic has inline comments\n- [ ] README updated if public API changed\n- [ ] Architecture diagrams in design.md are accurate\n\n#### Performance\n- [ ] No performance regressions (< 5% CPU increase)\n- [ ] Memory usage unchanged (< 10KB increase)\n- [ ] Latency requirements met (progress < 100ms)\n\n**Acceptance Criteria:**\n- ✓ All checklist items pass\n- ✓ Code review notes documented\n- ✓ Any issues found are addressed\n\n**Time Estimate:** 1 hour\n\n---\n\n## Summary\n\n### Total Task Count: 20 tasks\n- Phase 1 (CalibrationManager): 1 task\n- Phase 2 (Analysis Thread): 3 tasks\n- Phase 3 (AudioEngine): 3 tasks\n- Phase 4 (AppContext): 4 tasks\n- Phase 5 (Integration Testing): 2 tasks\n- Phase 6 (Documentation): 3 tasks\n\n### Time Estimates\n| Phase | Time Estimate |\n|---|---|\n| Phase 1: CalibrationManager | 0.5 hours |\n| Phase 2: Analysis Thread | 3.25 hours |\n| Phase 3: AudioEngine | 1.25 hours |\n| Phase 4: AppContext | 1.67 hours |\n| Phase 5: Integration Testing | 3.5 hours |\n| Phase 6: Documentation | 2.33 hours |\n| **Total** | **~12.5 hours** |\n\n### Test Coverage Goals\n- **Unit Tests**: ≥ 90% coverage for modified code\n- **Integration Tests**: End-to-end calibration workflow\n- **Manual Tests**: Real device testing with actual beatbox sounds\n\n### Dependencies Between Tasks\n```\n1.1 (CalibrationManager)\n  ↓\n2.1 → 2.2 → 2.3 (Analysis Thread)\n  ↓\n3.1 → 3.2 → 3.3 (AudioEngine)\n  ↓\n4.4 → 4.1 → 4.2 → 4.3 (AppContext)\n  ↓\n5.1 → 5.2 (Integration Testing)\n  ↓\n6.1 → 6.2 → 6.3 (Documentation)\n```\n\n**Critical Path**: 1.1 → 2.1 → 2.2 → 2.3 → 4.2 → 4.3 → 5.2\n\n### Risk Mitigation\n\n**Risk 1: Audio restart causes noticeable gap**\n- Mitigation: Measure latency in Task 5.2, optimize if > 200ms\n- Fallback: Implement Option B from design (no restart needed)\n\n**Risk 2: Lock contention in analysis thread**\n- Mitigation: Use try_lock() for state check, profile in Task 5.2\n- Fallback: Add lock-free flag for calibration state\n\n**Risk 3: Integration test complexity**\n- Mitigation: Start with unit tests, defer full integration test\n- Fallback: Rely on manual testing for initial implementation\n\n### Success Metrics (from requirements.md)\n\nThe implementation will be considered successful if:\n\n1. **Functional Completeness:**\n   - All user stories pass acceptance criteria\n   - All functional requirements implemented (FR-1 to FR-7)\n   - End-to-end calibration completes without errors\n\n2. **Performance:**\n   - Calibration time < 2 minutes (user-driven)\n   - Progress latency < 100ms\n   - No audio dropouts during calibration\n\n3. **Quality:**\n   - Unit test coverage ≥ 90%\n   - Integration tests pass\n   - Zero crashes over 100 runs\n   - Code review passes (SOLID, < 500 lines/file)\n\n4. **User Experience:**\n   - Real-time progress feedback visible\n   - Smooth sound type transitions\n   - Completion message confirms success\n   - Calibration persists across restarts\n",
  "fileStats": {
    "size": 34240,
    "lines": 1133,
    "lastModified": "2025-11-14T12:50:28.642Z"
  },
  "comments": []
}