{
  "id": "snapshot_1763124461480_p8nuq66fh",
  "approvalId": "approval_1763124430321_7dwf2btgy",
  "approvalTitle": "Calibration Workflow Design Document",
  "version": 2,
  "timestamp": "2025-11-14T12:47:41.480Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Calibration Workflow Fix - Design Document\n\n## 1. Executive Summary\n\nThis design document addresses the architectural gap in the calibration system: **onset detection events are not being forwarded to the calibration procedure's sample collection logic**.\n\n### Current State\n\nThe system has all necessary components in place:\n- ✓ Audio engine with Oboe full-duplex I/O\n- ✓ Onset detection in analysis thread (`spawn_analysis_thread`)\n- ✓ Feature extraction (spectral centroid, ZCR, flatness, rolloff, decay time)\n- ✓ Calibration procedure with `add_sample()` method\n- ✓ Progress broadcasting infrastructure\n- ✗ **Missing**: Connection between onset detection and calibration sample collection\n\n### Architectural Solution\n\n**Core Insight**: The analysis thread (`rust/src/analysis/mod.rs:73-158`) currently only performs classification. We need to add **calibration mode** where the analysis thread forwards detected onsets to the calibration procedure instead of classifying them.\n\n**Implementation Strategy**:\n1. Add calibration procedure reference to analysis thread\n2. Check calibration state on each onset\n3. If calibration is active, forward features to `CalibrationProcedure::add_sample()`\n4. Broadcast progress updates after each successful sample\n5. If calibration is inactive, proceed with normal classification\n\n## 2. System Architecture\n\n### 2.1 Component Overview\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                           UI Layer (Dart)                        │\n├─────────────────────────────────────────────────────────────────┤\n│  • CalibrationStream (receives CalibrationProgress)             │\n│  • ClassificationStream (receives ClassificationResult)          │\n└───────────────┬─────────────────────────────────┬───────────────┘\n                │ FFI Bridge (flutter_rust_bridge) │\n┌───────────────▼─────────────────────────────────▼───────────────┐\n│                      API Layer (rust/src/api.rs)                │\n├─────────────────────────────────────────────────────────────────┤\n│  • calibration_stream() → StreamSink<CalibrationProgress>       │\n│  • classification_stream() → StreamSink<ClassificationResult>   │\n└───────────────┬─────────────────────────────────┬───────────────┘\n                │                                 │\n┌───────────────▼─────────────────────────────────▼───────────────┐\n│              AppContext (rust/src/context.rs)                    │\n├─────────────────────────────────────────────────────────────────┤\n│  • AudioEngineManager    • CalibrationManager                   │\n│  • BroadcastChannelManager                                      │\n└──────┬────────────────────────────┬─────────────────────────────┘\n       │                            │\n       │                            │ Calibration Arc<Mutex<>>\n       │                            │\n┌──────▼────────────────────┐  ┌───▼──────────────────────────────┐\n│   AudioEngine             │  │   CalibrationManager             │\n│  (rust/src/audio/         │  │  (rust/src/managers/             │\n│   engine.rs)              │  │   calibration_manager.rs)        │\n├───────────────────────────┤  ├──────────────────────────────────┤\n│  • OUTPUT stream (master) │  │  • procedure: Arc<Mutex<         │\n│  • INPUT stream (slave)   │  │      Option<Calibration          │\n│  • Metronome generation   │  │      Procedure>>>                │\n│  • Frame counter          │  │  • state: Arc<RwLock<            │\n│  • BPM atomic             │  │      CalibrationState>>          │\n└──────┬────────────────────┘  └──────────────────────────────────┘\n       │\n       │ Lock-free buffer pool (rtrb queues)\n       │\n┌──────▼──────────────────────────────────────────────────────────┐\n│           Analysis Thread (rust/src/analysis/mod.rs)            │\n├─────────────────────────────────────────────────────────────────┤\n│  Loop:                                                           │\n│    1. Pop audio buffer from DATA_QUEUE                          │\n│    2. OnsetDetector::process() → Vec<u64> onset timestamps      │\n│    3. For each onset:                                           │\n│       a. Extract 1024-sample window                             │\n│       b. FeatureExtractor::extract() → Features                 │\n│       c. [NEW] Check if calibration is active                   │\n│          - IF calibration active:                               │\n│              • procedure.add_sample(features)                   │\n│              • Broadcast CalibrationProgress                    │\n│          - ELSE:                                                │\n│              • Classifier::classify_level1()                    │\n│              • Quantizer::quantize()                            │\n│              • Broadcast ClassificationResult                   │\n│    4. Return buffer to POOL_QUEUE                               │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### 2.2 Data Flow Diagram\n\n**Normal Classification Mode** (current, working):\n```\nAudio Callback → Buffer Pool → Analysis Thread → OnsetDetector → Features\n                                                                      ↓\nUI ← Broadcast ← ClassificationResult ← Quantizer ← Classifier ← Features\n```\n\n**Calibration Mode** (to be implemented):\n```\nAudio Callback → Buffer Pool → Analysis Thread → OnsetDetector → Features\n                                                                      ↓\nUI ← Broadcast ← CalibrationProgress ← CalibrationProcedure.add_sample()\n```\n\n**Key Decision Point**: Analysis thread checks calibration state to determine mode.\n\n## 3. Detailed Design\n\n### 3.1 Modified Analysis Thread Signature\n\n**Current (rust/src/analysis/mod.rs:73-80)**:\n```rust\npub fn spawn_analysis_thread(\n    mut analysis_channels: AnalysisThreadChannels,\n    calibration: Arc<RwLock<CalibrationState>>,  // Only state, not procedure!\n    frame_counter: Arc<AtomicU64>,\n    bpm: Arc<AtomicU32>,\n    sample_rate: u32,\n    result_sender: tokio::sync::broadcast::Sender<ClassificationResult>,\n) -> JoinHandle<()>\n```\n\n**NEW Design**:\n```rust\npub fn spawn_analysis_thread(\n    mut analysis_channels: AnalysisThreadChannels,\n    calibration_state: Arc<RwLock<CalibrationState>>,     // For classification\n    calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>, // NEW: For sample collection\n    calibration_progress_tx: Option<broadcast::Sender<CalibrationProgress>>, // NEW: For progress\n    frame_counter: Arc<AtomicU64>,\n    bpm: Arc<AtomicU32>,\n    sample_rate: u32,\n    result_sender: tokio::sync::broadcast::Sender<ClassificationResult>,\n) -> JoinHandle<()>\n```\n\n**Rationale**:\n- `calibration_procedure`: Shared reference to active calibration procedure (None if not calibrating)\n- `calibration_progress_tx`: Optional broadcast channel for calibration progress\n- Keep existing `calibration_state` for classification mode\n- Backward compatible: If `calibration_procedure` is None, behaves exactly as before\n\n### 3.2 Analysis Thread Main Loop Logic\n\n**NEW Processing Logic** (replaces lines 104-146 in `rust/src/analysis/mod.rs`):\n\n```rust\n// For each detected onset, run pipeline\nfor onset_timestamp in onsets {\n    // Extract 1024-sample window starting at onset\n    let onset_idx = (onset_timestamp % buffer.len() as u64) as usize;\n\n    if onset_idx + 1024 <= buffer.len() {\n        let onset_window = &buffer[onset_idx..onset_idx + 1024];\n\n        // Extract DSP features (always needed for both modes)\n        let features = feature_extractor.extract(onset_window);\n\n        // NEW: Check if calibration is active\n        let calibration_active = if let Ok(procedure_guard) = calibration_procedure.try_lock() {\n            procedure_guard.is_some()\n        } else {\n            false // Lock failed, assume not calibrating\n        };\n\n        if calibration_active {\n            // ====== CALIBRATION MODE ======\n            // Forward features to calibration procedure\n            if let Ok(mut procedure_guard) = calibration_procedure.lock() {\n                if let Some(ref mut procedure) = *procedure_guard {\n                    match procedure.add_sample(features) {\n                        Ok(()) => {\n                            // Sample accepted - broadcast progress\n                            let progress = procedure.get_progress();\n\n                            if let Some(ref tx) = calibration_progress_tx {\n                                let _ = tx.send(progress);\n                            }\n                        }\n                        Err(err) => {\n                            // Sample rejected (validation error)\n                            eprintln!(\"Calibration sample rejected: {:?}\", err);\n                            // Optionally broadcast error (future enhancement)\n                        }\n                    }\n                }\n            }\n        } else {\n            // ====== CLASSIFICATION MODE (existing logic) ======\n            let (sound, confidence) = classifier.classify_level1(&features);\n\n            let current_bpm = bpm.load(std::sync::atomic::Ordering::Relaxed);\n            let timing = if current_bpm > 0 {\n                quantizer.quantize(onset_timestamp)\n            } else {\n                TimingFeedback {\n                    classification: quantizer::TimingClassification::OnTime,\n                    error_ms: 0.0,\n                }\n            };\n\n            let timestamp_ms = (onset_timestamp as f64 / sample_rate as f64 * 1000.0) as u64;\n\n            let result = ClassificationResult {\n                sound,\n                timing,\n                timestamp_ms,\n                confidence,\n            };\n\n            let _ = result_sender.send(result);\n        }\n    }\n}\n```\n\n**Key Design Decisions**:\n1. **Non-blocking lock attempt**: Use `try_lock()` for calibration state check to avoid blocking audio analysis\n2. **Graceful degradation**: If lock fails, assume not calibrating and proceed with classification\n3. **Validation errors are logged**: Invalid samples don't crash the thread\n4. **Progress broadcast after each sample**: Real-time UI feedback\n\n### 3.3 AudioEngine Modifications\n\n**Current start() method** (rust/src/audio/engine.rs:211-252):\n```rust\npub fn start(\n    &mut self,\n    calibration: Arc<RwLock<CalibrationState>>,\n    result_sender: broadcast::Sender<ClassificationResult>,\n) -> Result<(), AudioError>\n```\n\n**NEW Design**:\n```rust\npub fn start(\n    &mut self,\n    calibration_state: Arc<RwLock<CalibrationState>>,\n    calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>,  // NEW\n    calibration_progress_tx: Option<broadcast::Sender<CalibrationProgress>>, // NEW\n    result_sender: broadcast::Sender<ClassificationResult>,\n) -> Result<(), AudioError>\n```\n\n**Modified spawn_analysis_thread_internal()** (lines 174-193):\n```rust\nfn spawn_analysis_thread_internal(\n    &self,\n    buffer_channels: BufferPoolChannels,\n    calibration_state: Arc<RwLock<CalibrationState>>,\n    calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>,  // NEW\n    calibration_progress_tx: Option<broadcast::Sender<CalibrationProgress>>, // NEW\n    result_sender: broadcast::Sender<ClassificationResult>,\n) {\n    let (_, analysis_channels) = buffer_channels.split_for_threads();\n\n    let frame_counter_clone = Arc::clone(&self.frame_counter);\n    let bpm_clone = Arc::clone(&self.bpm);\n\n    crate::analysis::spawn_analysis_thread(\n        analysis_channels,\n        calibration_state,\n        calibration_procedure,          // NEW: Pass to analysis thread\n        calibration_progress_tx,        // NEW: Pass to analysis thread\n        frame_counter_clone,\n        bpm_clone,\n        self.sample_rate,\n        result_sender,\n    );\n}\n```\n\n### 3.4 AppContext Integration\n\n**Current start_calibration()** (rust/src/context.rs):\n```rust\npub fn start_calibration(&self) -> Result<(), CalibrationError> {\n    let broadcast_tx = self.broadcasts.init_calibration();\n    self.calibration.start(broadcast_tx)?;\n\n    #[cfg(target_os = \"android\")]\n    {\n        const DEFAULT_CALIBRATION_BPM: u32 = 120;\n        self.start_audio(DEFAULT_CALIBRATION_BPM)\n            .map_err(|audio_err| CalibrationError::AudioEngineError {\n                details: format!(\"Failed to start audio engine: {:?}\", audio_err),\n            })?;\n    }\n\n    Ok(())\n}\n```\n\n**Issues with current design**:\n1. Audio engine is started AFTER calibration procedure is initialized\n2. Analysis thread doesn't have access to calibration procedure\n3. No way to pass procedure reference to already-running analysis thread\n\n**NEW Design - Two Options**:\n\n#### Option A: Restart Audio Engine (Simpler, Slight Latency)\n```rust\npub fn start_calibration(&self) -> Result<(), CalibrationError> {\n    // Initialize calibration procedure\n    let broadcast_tx = self.broadcasts.init_calibration();\n    self.calibration.start(broadcast_tx)?;\n\n    #[cfg(target_os = \"android\")]\n    {\n        // Stop audio engine if running\n        self.stop_audio()?;\n\n        // Restart audio engine with calibration procedure\n        const DEFAULT_CALIBRATION_BPM: u32 = 120;\n        self.start_audio(DEFAULT_CALIBRATION_BPM)\n            .map_err(|audio_err| CalibrationError::AudioEngineError {\n                details: format!(\"Failed to start audio engine: {:?}\", audio_err),\n            })?;\n    }\n\n    Ok(())\n}\n```\n\n**Pros**:\n- Simpler implementation\n- Clean separation of concerns\n- Analysis thread gets fresh calibration procedure reference\n\n**Cons**:\n- Brief audio interruption (~100ms) during calibration start\n- User hears metronome stop and restart\n\n#### Option B: Pass Procedure at Audio Startup (Cleaner, More Complex)\n```rust\n// Modify AudioEngineManager to store calibration references\npub struct AudioEngineManager {\n    engine: Option<AudioEngine>,\n    calibration_state: Arc<RwLock<CalibrationState>>,\n    calibration_procedure: Arc<Mutex<Option<CalibrationProcedure>>>,  // NEW: Stored reference\n    // ...\n}\n```\n\n**Pros**:\n- No audio interruption\n- Seamless calibration start\n\n**Cons**:\n- More complex state management\n- AudioEngineManager now depends on calibration (coupling)\n- Procedure reference must be shared between CalibrationManager and AudioEngineManager\n\n**RECOMMENDED**: **Option A** for initial implementation (follows KISS principle)\n- User impact is minimal (brief metronome restart)\n- Simpler to test and maintain\n- Can optimize to Option B later if needed\n\n### 3.5 Calibration Manager Modifications\n\n**Current CalibrationManager** (rust/src/managers/calibration_manager.rs):\n- Stores `Arc<Mutex<Option<CalibrationProcedure>>>`\n- Already has `start()` and `finish()` methods\n- No modifications needed!\n\n**Integration Points**:\n1. AppContext calls `calibration.start(broadcast_tx)` to initialize procedure\n2. AppContext gets procedure reference via `calibration.get_procedure_arc()` (NEW method)\n3. Pass procedure reference to AudioEngine on start/restart\n\n**NEW Method to Add**:\n```rust\nimpl CalibrationManager {\n    /// Get Arc reference to calibration procedure for sharing with audio engine\n    ///\n    /// # Returns\n    /// `Arc<Mutex<Option<CalibrationProcedure>>>` - Thread-safe reference to procedure\n    pub fn get_procedure_arc(&self) -> Arc<Mutex<Option<CalibrationProcedure>>> {\n        Arc::clone(&self.procedure)\n    }\n}\n```\n\n## 4. Thread Safety Analysis\n\n### 4.1 Lock Hierarchy\n\n```\nAudio Callback (highest priority, real-time thread)\n    ↓ No locks, only atomics and lock-free queues\nAnalysis Thread (normal priority, async thread)\n    ↓ Locks: Mutex<Option<CalibrationProcedure>>, RwLock<CalibrationState>\nUI Thread (normal priority, Dart/Flutter)\n    ↓ Receives via broadcast channels (no locks)\n```\n\n**Lock Acquisition Order** (prevents deadlocks):\n1. Analysis thread: Try `calibration_procedure.try_lock()` for state check (non-blocking)\n2. Analysis thread: `calibration_procedure.lock()` for sample add (blocking OK in analysis thread)\n3. Never hold multiple locks simultaneously\n\n### 4.2 Lock-Free Guarantees\n\n**Audio Callback** (rust/src/audio/callback.rs):\n- ✓ No locks (only `Arc<AtomicU64>`, `Arc<AtomicU32>`)\n- ✓ No allocations\n- ✓ Lock-free buffer pool (rtrb queues)\n- ✓ Real-time safe\n\n**Analysis Thread**:\n- ✓ Can block (not real-time critical)\n- ✓ Locks are acceptable\n- ✓ Graceful fallback if lock fails (`try_lock()` for state check)\n\n### 4.3 Race Condition Analysis\n\n**Scenario 1**: User starts calibration while audio is playing\n- AppContext stops audio → initializes procedure → restarts audio\n- Audio callbacks stop during gap → analysis thread drains queue → new audio callbacks start\n- **Safe**: No concurrent modification during transition\n\n**Scenario 2**: User finishes calibration while onset is being processed\n- Analysis thread locks procedure → adds sample → releases lock\n- CalibrationManager locks procedure → calls finalize() → sets to None\n- **Safe**: Sequential lock acquisition, no data race\n\n**Scenario 3**: Calibration procedure is finalized between try_lock() and lock()\n- Analysis thread: `try_lock()` → true (procedure exists)\n- CalibrationManager: `lock()` → `finalize()` → procedure becomes None\n- Analysis thread: `lock()` → procedure is now None → skip sample add\n- **Safe**: Option<> handles None case gracefully\n\n## 5. Error Handling Strategy\n\n### 5.1 Error Scenarios and Responses\n\n| Error Scenario | Detection Point | Response | User Impact |\n|---|---|---|---|\n| Invalid features (out of range) | `SampleValidator::validate()` | Log error, skip sample | None (silent rejection) |\n| Lock poisoning on procedure | `calibration_procedure.lock()` | Log error, skip sample | None (continues processing) |\n| Broadcast channel closed | `calibration_progress_tx.send()` | Ignore (no subscribers) | None (UI disconnected) |\n| Insufficient samples on finalize | `CalibrationProcedure::finalize()` | Return `CalibrationError` | UI shows error message |\n| Audio engine failure during start | `AudioEngine::start()` | Return `CalibrationError` | UI shows error message |\n\n### 5.2 Error Propagation\n\n```\nAnalysis Thread (onset processing)\n    ↓ Invalid features → Log warning, continue\n    ↓ Lock failure → Log warning, continue\n    ↓ Broadcast failure → Silent ignore, continue\n\nCalibrationManager::finish()\n    ↓ Insufficient samples → Return CalibrationError\n    ↓ Lock poisoning → Return CalibrationError\n\nAppContext::start_calibration()\n    ↓ Audio engine failure → Map to CalibrationError::AudioEngineError\n    ↓ Propagate to Dart via FFI error code\n```\n\n**Design Principle**: Fail fast at API boundaries, fail gracefully in background threads.\n\n### 5.3 Structured Error Logging\n\n**Format** (from CLAUDE.md guidelines):\n```json\n{\n  \"timestamp\": \"2025-11-14T12:43:20.214Z\",\n  \"level\": \"ERROR\",\n  \"service\": \"calibration\",\n  \"event\": \"sample_rejected\",\n  \"context\": {\n    \"reason\": \"Centroid 30.0 Hz out of range [50.0, 24000.0]\",\n    \"current_sound\": \"KICK\",\n    \"samples_collected\": 5\n  }\n}\n```\n\n## 6. Performance Considerations\n\n### 6.1 Latency Analysis\n\n**Calibration Sample Processing**:\n```\nOnset detection:        ~20ms  (spectral flux analysis)\nFeature extraction:     ~10ms  (FFT + feature computation)\nSample validation:      ~0.1ms (range checks)\nMutex lock acquisition: ~0.01ms (uncontended)\nProgress broadcast:     ~0.01ms (channel send)\n──────────────────────────────\nTotal:                  ~30ms  (well within 100ms requirement)\n```\n\n**Memory Allocation**:\n- Features struct: 5 × f32 = 20 bytes (stack allocated)\n- Progress struct: ~40 bytes (stack allocated, cloned for broadcast)\n- No heap allocations in hot path ✓\n\n### 6.2 Throughput\n\n**Expected Onset Rate**:\n- User performs beatbox sound every ~2 seconds\n- Onset detection processes entire buffer (~10ms @ 48kHz, 480 samples)\n- Typical onset rate: 0.5 onsets/second during calibration\n- Analysis thread CPU usage: ~1-2% (plenty of headroom)\n\n**Lock Contention**:\n- Calibration procedure lock held for ~0.1ms per sample\n- Single writer (analysis thread), no readers during calibration\n- Lock contention: Negligible\n\n### 6.3 Memory Footprint\n\n**Per-Calibration Memory**:\n- CalibrationProcedure: 3 × Vec<Features> × 10 samples = ~600 bytes\n- Broadcast channel: 100 slot buffer × 40 bytes = 4KB\n- Total: ~5KB (negligible for mobile device)\n\n## 7. Testing Strategy\n\n### 7.1 Unit Tests\n\n**Test Coverage Requirements**: ≥ 90% (from requirements)\n\n#### 7.1.1 Analysis Thread Tests\n\n**File**: `rust/src/analysis/mod.rs` (new test module)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_calibration_mode_forwards_to_procedure() {\n        // Setup: Initialize analysis thread with mock procedure\n        // Action: Feed audio buffer with synthetic onset\n        // Assert: procedure.add_sample() called with correct features\n    }\n\n    #[test]\n    fn test_classification_mode_when_procedure_is_none() {\n        // Setup: procedure = None\n        // Action: Feed audio buffer with onset\n        // Assert: ClassificationResult broadcast, no calibration call\n    }\n\n    #[test]\n    fn test_invalid_features_rejected_gracefully() {\n        // Setup: Mock validator to return error\n        // Action: Feed buffer with invalid onset\n        // Assert: Error logged, thread continues\n    }\n\n    #[test]\n    fn test_progress_broadcast_after_each_sample() {\n        // Setup: Mock broadcast channel\n        // Action: Add 3 samples\n        // Assert: 3 progress broadcasts sent\n    }\n\n    #[test]\n    fn test_lock_failure_fallback_to_classification() {\n        // Setup: Poison procedure lock\n        // Action: Feed buffer with onset\n        // Assert: Falls back to classification mode\n    }\n}\n```\n\n#### 7.1.2 CalibrationManager Tests\n\n**File**: `rust/src/managers/calibration_manager.rs` (add to existing tests)\n\n```rust\n#[test]\nfn test_get_procedure_arc() {\n    let manager = CalibrationManager::new();\n    let (broadcast_tx, _) = broadcast::channel(100);\n\n    // Start calibration\n    manager.start(broadcast_tx).unwrap();\n\n    // Get procedure arc\n    let procedure_arc = manager.get_procedure_arc();\n\n    // Verify procedure is accessible via arc\n    let procedure_guard = procedure_arc.lock().unwrap();\n    assert!(procedure_guard.is_some());\n}\n```\n\n### 7.2 Integration Tests\n\n#### 7.2.1 End-to-End Calibration Workflow\n\n**File**: `rust/tests/calibration_integration_test.rs`\n\n```rust\n#[test]\nfn test_full_calibration_workflow() {\n    // 1. Initialize AppContext\n    // 2. Call start_calibration()\n    // 3. Feed synthetic audio with 30 beatbox sounds (10 kick, 10 snare, 10 hihat)\n    // 4. Verify 30 progress broadcasts received\n    // 5. Call finish_calibration()\n    // 6. Verify CalibrationState is persisted with correct thresholds\n    // 7. Verify audio engine can restart in classification mode\n}\n\n#[test]\nfn test_calibration_with_invalid_samples() {\n    // 1. Start calibration\n    // 2. Feed 8 valid samples + 2 invalid samples\n    // 3. Verify only 8 samples accepted\n    // 4. Verify progress shows 8/10\n    // 5. Feed 2 more valid samples\n    // 6. Verify progression to next sound\n}\n\n#[test]\nfn test_calibration_restart_audio_interruption() {\n    // 1. Start audio engine in classification mode\n    // 2. Start calibration (triggers audio restart)\n    // 3. Verify audio gap is < 200ms\n    // 4. Verify metronome resumes correctly\n}\n```\n\n### 7.3 Synthetic Audio Test Data\n\n**Test Audio Generation**:\n```rust\n/// Generate synthetic beatbox sounds for testing\nmod test_audio {\n    /// Generate kick drum: Low centroid (500 Hz), high decay (100ms)\n    pub fn generate_kick() -> Vec<f32> { /* ... */ }\n\n    /// Generate snare: Mid centroid (3000 Hz), high ZCR (0.2)\n    pub fn generate_snare() -> Vec<f32> { /* ... */ }\n\n    /// Generate hi-hat: High centroid (8000 Hz), high flatness (0.7)\n    pub fn generate_hihat() -> Vec<f32> { /* ... */ }\n\n    /// Generate invalid sample: Out-of-range features\n    pub fn generate_invalid() -> Vec<f32> { /* ... */ }\n}\n```\n\n### 7.4 Mock Dependencies\n\n**CalibrationProcedure Mock** (for testing analysis thread):\n```rust\npub struct MockCalibrationProcedure {\n    samples_received: Arc<Mutex<Vec<Features>>>,\n    validation_result: Result<(), CalibrationError>,\n}\n\nimpl MockCalibrationProcedure {\n    pub fn new() -> Self { /* ... */ }\n\n    pub fn add_sample(&mut self, features: Features) -> Result<(), CalibrationError> {\n        self.samples_received.lock().unwrap().push(features);\n        self.validation_result.clone()\n    }\n\n    pub fn get_samples_received(&self) -> Vec<Features> {\n        self.samples_received.lock().unwrap().clone()\n    }\n}\n```\n\n## 8. Migration Path\n\n### 8.1 Implementation Phases\n\n**Phase 1: Analysis Thread Modifications** (2-3 hours)\n- Modify `spawn_analysis_thread()` signature\n- Add calibration mode logic to main loop\n- Add unit tests for calibration mode\n\n**Phase 2: AudioEngine Integration** (1-2 hours)\n- Modify `AudioEngine::start()` signature\n- Update `spawn_analysis_thread_internal()`\n- Add unit tests for parameter passing\n\n**Phase 3: AppContext Integration** (1-2 hours)\n- Implement audio restart logic in `start_calibration()`\n- Add `CalibrationManager::get_procedure_arc()`\n- Wire up calibration procedure to audio engine\n\n**Phase 4: Integration Testing** (2-3 hours)\n- End-to-end calibration workflow test\n- Invalid sample handling test\n- Audio restart latency test\n\n**Phase 5: Manual Testing** (1 hour)\n- Deploy to Android device\n- Perform calibration with real beatbox sounds\n- Verify progress updates in UI\n- Verify threshold computation\n\n**Total Estimated Time**: 7-11 hours\n\n### 8.2 Rollback Strategy\n\n**If issues arise during implementation**:\n1. Revert analysis thread changes (restore lines 104-146 in `rust/src/analysis/mod.rs`)\n2. Revert `AudioEngine::start()` signature\n3. Keep `CalibrationManager::get_procedure_arc()` (harmless addition)\n4. System returns to previous state: audio works, calibration doesn't send progress\n\n**Risk Mitigation**:\n- All changes are additive (no removal of existing functionality)\n- Backward compatible signatures (use Option<> for new parameters)\n- Extensive unit tests before integration\n\n## 9. API Changes Summary\n\n### 9.1 Modified Functions\n\n| Function | File | Change Type | Breaking? |\n|---|---|---|---|\n| `spawn_analysis_thread()` | `rust/src/analysis/mod.rs:73` | Add parameters | Yes* |\n| `AudioEngine::start()` | `rust/src/audio/engine.rs:211` | Add parameters | Yes* |\n| `spawn_analysis_thread_internal()` | `rust/src/audio/engine.rs:174` | Add parameters | No (private) |\n\n*Breaking for internal calls only (not public API)\n\n### 9.2 New Functions\n\n| Function | File | Purpose |\n|---|---|---|\n| `CalibrationManager::get_procedure_arc()` | `rust/src/managers/calibration_manager.rs` | Get procedure reference for audio engine |\n\n### 9.3 FFI/Public API\n\n**No changes to FFI boundary** - All modifications are internal to Rust layer.\n\nDart API remains unchanged:\n- `start_calibration()` - No signature change\n- `calibration_stream()` - No signature change\n- `finish_calibration()` - No signature change\n\n## 10. Alternatives Considered\n\n### 10.1 Alternative 1: Callback-Based Architecture\n\n**Idea**: Pass callback function to analysis thread instead of procedure reference.\n\n```rust\ntype CalibrationCallback = Box<dyn Fn(Features) -> Result<CalibrationProgress, CalibrationError> + Send>;\n\npub fn spawn_analysis_thread(\n    // ...\n    calibration_callback: Option<CalibrationCallback>,\n) -> JoinHandle<()>\n```\n\n**Pros**:\n- Decouples analysis thread from calibration types\n- More flexible for future extensions\n\n**Cons**:\n- Heap allocation for boxed closure (not real-time safe for future optimizations)\n- Harder to test (mocking closures is complex)\n- Overkill for single use case\n\n**Verdict**: **Rejected** - Adds complexity without clear benefit.\n\n### 10.2 Alternative 2: Message-Passing Architecture\n\n**Idea**: Analysis thread sends features to calibration thread via channel.\n\n```rust\n// Analysis thread\nlet _ = calibration_tx.send(features);\n\n// Calibration thread\nwhile let Ok(features) = calibration_rx.recv() {\n    procedure.add_sample(features)?;\n}\n```\n\n**Pros**:\n- Complete decoupling of threads\n- Easier to add more consumers of onset features\n\n**Cons**:\n- Extra thread overhead\n- Extra latency (~1-2ms for channel send/receive)\n- More complex error handling (what if channel is full?)\n- Overkill for single consumer\n\n**Verdict**: **Rejected** - Unnecessary complexity and latency for single consumer.\n\n### 10.3 Alternative 3: Global Calibration State\n\n**Idea**: Use global static for calibration procedure.\n\n```rust\nstatic CALIBRATION_PROCEDURE: Lazy<Arc<Mutex<Option<CalibrationProcedure>>>> =\n    Lazy::new(|| Arc::new(Mutex::new(None)));\n```\n\n**Pros**:\n- No need to pass procedure through function signatures\n- Simple access from any thread\n\n**Cons**:\n- Global mutable state (violates SOLID principles from CLAUDE.md)\n- Hard to test (global state persists between tests)\n- Hidden dependencies (makes call graph unclear)\n- Not compatible with dependency injection\n\n**Verdict**: **Rejected** - Violates project guidelines (DI mandatory, no globals).\n\n### 10.4 Selected Approach: Direct Procedure Reference\n\n**Rationale**:\n- ✓ Explicit dependencies (follows DI principle)\n- ✓ Easy to test (inject mock procedure)\n- ✓ No extra latency\n- ✓ Clear ownership (Arc<Mutex<>> for shared access)\n- ✓ Minimal code changes\n\n## 11. Future Enhancements\n\n### 11.1 Automatic Calibration Quality Assessment\n\n**Idea**: Analyze collected samples for quality metrics.\n\n```rust\npub struct CalibrationQuality {\n    pub kick_consistency: f32,    // 0.0-1.0 (low variance = high consistency)\n    pub snare_consistency: f32,\n    pub hihat_consistency: f32,\n    pub separation_score: f32,    // How distinct the sounds are\n}\n\nimpl CalibrationProcedure {\n    pub fn assess_quality(&self) -> CalibrationQuality { /* ... */ }\n}\n```\n\n**Benefit**: Warn user if calibration quality is low, suggest recalibration.\n\n### 11.2 Real-Time Sample Feedback\n\n**Idea**: Provide per-sample feedback (not just progress count).\n\n```rust\npub enum SampleFeedback {\n    Accepted { quality_score: f32 },\n    Rejected { reason: String, suggestion: String },\n    TooSimilarToPrevious,  // Encourage variety\n}\n```\n\n**Benefit**: Help user understand which sounds are good/bad during calibration.\n\n### 11.3 Adaptive Sample Count\n\n**Idea**: Stop collecting samples early if consistency is high.\n\n```rust\npub struct CalibrationProcedure {\n    samples_needed: Range<u8>,  // e.g., 5-10 samples\n    consistency_threshold: f32,  // e.g., 0.9\n}\n```\n\n**Benefit**: Reduce calibration time from 2 minutes to <1 minute for consistent users.\n\n### 11.4 Calibration Recovery\n\n**Idea**: Save partial calibration state to disk, resume after app crash.\n\n```rust\npub fn save_partial_calibration(&self) -> Result<(), std::io::Error> {\n    let state = PartialCalibrationState {\n        kick_samples: self.kick_samples.clone(),\n        snare_samples: self.snare_samples.clone(),\n        current_sound: self.current_sound,\n    };\n    // Serialize to JSON and save\n}\n```\n\n**Benefit**: User doesn't have to restart calibration if app crashes mid-process.\n\n## 12. Open Questions\n\n### Q1: Should we stop metronome during calibration?\n\n**Current**: Metronome plays at 120 BPM during calibration\n**Alternative**: Silence metronome, only collect onset samples\n\n**Pros of metronome**:\n- Guides user timing (makes it easier to perform sounds)\n- Consistent with normal usage (users practice with metronome)\n\n**Pros of silence**:\n- Reduces audio interference (metronome click might affect onset detection)\n- Simpler audio processing\n\n**Recommendation**: Keep metronome (user guidance is valuable)\n**Fallback**: If interference is observed, add flag to disable metronome during calibration\n\n### Q2: Should we provide visual feedback for each sample?\n\n**Current**: Progress shows \"3/10 samples\" (count only)\n**Alternative**: Show checkmark or X for each sample (visual history)\n\n**Implementation**: Modify `CalibrationProgress` to include sample acceptance status\n```rust\npub struct CalibrationProgress {\n    pub current_sound: String,\n    pub samples_collected: u8,\n    pub total_samples_needed: u8,\n    pub last_sample_status: Option<SampleFeedback>,  // NEW\n}\n```\n\n**Recommendation**: Defer to future enhancement (Phase 2 feature)\n**Rationale**: Keeps initial implementation simple, can add later based on user feedback\n\n### Q3: Should we allow user to skip invalid samples?\n\n**Current**: Invalid samples are silently rejected\n**Alternative**: Pause calibration, show error, let user retry or skip\n\n**Pros of skip**:\n- User has control\n- Avoids frustration if user can't produce valid sound\n\n**Cons of skip**:\n- More complex UI flow\n- Risk of low-quality calibration (user skips all difficult samples)\n\n**Recommendation**: Keep auto-rejection (simpler UX)\n**Rationale**: Sample validation is lenient (wide ranges), invalid samples are rare\n\n## 13. Success Criteria\n\nThe design will be considered successful if it meets the following criteria:\n\n### 13.1 Functional Completeness\n- ✓ Onset detection forwards features to calibration procedure during calibration mode\n- ✓ Progress updates broadcast after each sample\n- ✓ Classification mode resumes after calibration completes\n- ✓ All 30 samples (10 × 3 sound types) can be collected successfully\n\n### 13.2 Performance\n- ✓ Progress broadcast latency < 100ms (measured from onset to UI update)\n- ✓ No audio dropouts during calibration\n- ✓ Analysis thread CPU usage < 5% average\n\n### 13.3 Quality\n- ✓ Unit test coverage ≥ 90% for modified code\n- ✓ Integration tests pass for full calibration workflow\n- ✓ No crashes observed over 100 calibration runs\n- ✓ Code review passes (SOLID, < 500 lines/file, < 50 lines/function)\n\n### 13.4 User Experience\n- ✓ UI shows real-time progress during calibration\n- ✓ Calibration completes in < 2 minutes (user-driven)\n- ✓ Error messages are clear and actionable\n- ✓ Saved calibration persists across app restarts\n\n## 14. Appendix\n\n### 14.1 Glossary\n\n- **Onset**: Percussive transient in audio signal (beginning of a beatbox sound)\n- **Feature Extraction**: Computing spectral characteristics (centroid, ZCR, etc.) from audio\n- **Spectral Centroid**: Weighted mean frequency (Hz), indicates \"brightness\" of sound\n- **Zero-Crossing Rate (ZCR)**: Ratio of sign changes in waveform, indicates noisiness\n- **Spectral Flatness**: Measure of tone-like vs. noise-like quality (0.0-1.0)\n- **Spectral Rolloff**: Frequency below which 85% of energy is concentrated\n- **Decay Time**: Time for signal amplitude to decay to -20dB\n- **Quantization**: Snapping onset timestamp to nearest metronome grid position\n- **Lock-Free**: Algorithm that doesn't use mutexes or blocking operations\n- **Real-Time Safety**: Guarantees bounded execution time (no allocations, locks, or blocking)\n\n### 14.2 References\n\n- **Oboe Documentation**: https://github.com/google/oboe/blob/main/docs/reference/\n- **flutter_rust_bridge Guide**: https://cjycode.com/flutter_rust_bridge/\n- **Tokio Broadcast Channels**: https://docs.rs/tokio/latest/tokio/sync/broadcast/\n- **rtrb Lock-Free Queues**: https://docs.rs/rtrb/latest/rtrb/\n- **Project Guidelines**: `.spec-workflow/steering/tech.md`, `~/.claude/CLAUDE.md`\n",
  "fileStats": {
    "size": 37587,
    "lines": 997,
    "lastModified": "2025-11-14T12:47:00.809Z"
  },
  "comments": []
}