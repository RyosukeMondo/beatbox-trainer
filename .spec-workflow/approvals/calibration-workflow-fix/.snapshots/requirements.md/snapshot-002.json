{
  "id": "snapshot_1763124200212_a7vx47ig0",
  "approvalId": "approval_1763124126369_tq04a0yno",
  "approvalTitle": "Calibration Workflow Requirements Document",
  "version": 2,
  "timestamp": "2025-11-14T12:43:20.212Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Calibration Workflow Fix - Requirements\n\n## 1. Introduction\n\nThe calibration system is a critical component of the Beatbox Trainer app that adapts sound classification to individual voice characteristics. Currently, the calibration workflow has an architectural gap: the audio engine detects onsets and extracts spectral features, but these features are never fed to the calibration procedure's sample collection logic.\n\nThis specification addresses the complete end-to-end calibration workflow to enable:\n- Onset detection during calibration sessions\n- Feature extraction and validation\n- Sample collection (10 samples per sound type: KICK, SNARE, HI-HAT)\n- Real-time progress feedback to the UI\n- Threshold computation and state persistence\n\n## 2. Alignment with Product Vision\n\n**From product.md:**\n> Calibration time < 2 minutes (10 samples × 3 sound types = 30 samples total)\n\n**From tech.md:**\n> Real-time audio processing with lock-free communication, sample-accurate metronome, < 20ms latency\n\nThis specification ensures the calibration workflow supports these goals by:\n1. Providing real-time progress updates (< 100ms latency)\n2. Enabling efficient sample collection through clear UI guidance\n3. Maintaining real-time safety with lock-free architecture\n4. Delivering reliable threshold computation for accurate classification\n\n## 3. User Stories\n\n### Story 1: Voice Calibration for Accurate Classification\n**As a** beatboxer\n**I want to** calibrate the app to my voice\n**So that** sound classification recognizes my unique technique and vocal characteristics\n\n**EARS Criteria:**\n- **WHEN** I start calibration\n- **WHILE** the audio engine is running\n- **IF** I perform a beatbox sound (KICK, SNARE, or HI-HAT)\n- **THEN** the system shall detect the onset within 50ms\n- **AND** extract spectral features (centroid, ZCR, flatness, rolloff, decay time)\n- **AND** validate features are within acceptable ranges\n- **AND** add the sample to the calibration procedure\n\n**Acceptance Criteria:**\n- ✓ Onset detection triggers within 50ms of transient\n- ✓ Features extracted match DSP specifications\n- ✓ Invalid samples (out of range) are rejected with clear error\n- ✓ Each sound type collects exactly 10 valid samples\n\n---\n\n### Story 2: Real-Time Progress Feedback\n**As a** user\n**I want to** see real-time progress during calibration\n**So that** I know the system is working and how many samples remain\n\n**EARS Criteria:**\n- **WHEN** a valid sample is collected\n- **THEN** the system shall broadcast a progress update within 100ms\n- **AND** the UI shall display:\n  - Current sound type being calibrated (KICK/SNARE/HI-HAT)\n  - Sample count (e.g., \"3/10 samples collected\")\n  - Visual/audio feedback confirming sample acceptance\n\n**Acceptance Criteria:**\n- ✓ Progress broadcast latency < 100ms\n- ✓ UI updates reflect sample count accurately\n- ✓ Progress stream continues until calibration completion or error\n- ✓ Stream ends gracefully when calibration finishes\n\n---\n\n### Story 3: Clear Calibration Instructions\n**As a** user\n**I want to** receive clear instructions for each sound type\n**So that** I know what beatbox sound to perform\n\n**EARS Criteria:**\n- **WHEN** calibration starts or progresses to the next sound type\n- **THEN** the system shall indicate the current sound type to perform\n- **AND** provide visual guidance (e.g., \"Perform KICK sound: 3/10 samples\")\n\n**Acceptance Criteria:**\n- ✓ Calibration sequence follows: KICK → SNARE → HI-HAT\n- ✓ UI displays current sound type prominently\n- ✓ Transition to next sound type occurs automatically after 10 samples\n- ✓ Completion message shown after all 30 samples collected\n\n---\n\n### Story 4: Testable Calibration Architecture\n**As a** developer\n**I want** unit-testable calibration logic\n**So that** the system is maintainable and regression-free\n\n**EARS Criteria:**\n- **WHEN** calibration logic is implemented\n- **THEN** each component shall be independently testable:\n  - Onset detection can be tested with synthetic audio\n  - Feature extraction can be tested with known spectral content\n  - Sample validation can be tested with boundary cases\n  - Threshold computation can be tested with mock sample sets\n  - Progress broadcasting can be tested with mock channels\n\n**Acceptance Criteria:**\n- ✓ Unit test coverage ≥ 90% for calibration modules\n- ✓ Integration tests verify onset → sample → progress flow\n- ✓ Mock dependencies injectable for testing\n- ✓ Edge cases tested: insufficient samples, invalid features, duplicate onsets\n\n## 4. Functional Requirements\n\n### FR-1: Onset Detection During Calibration\n**Requirement:** The audio engine shall detect percussive transients during calibration sessions.\n\n**Details:**\n- Use spectral flux analysis for onset detection\n- Threshold-based trigger to distinguish onset from noise\n- Sample-accurate timestamp using frame counter\n\n**Rationale:** Calibration requires detecting when the user performs a beatbox sound.\n\n---\n\n### FR-2: Feature Extraction\n**Requirement:** For each detected onset, the system shall extract the following spectral features:\n\n1. **Spectral Centroid** (Hz): Weighted mean frequency\n2. **Zero-Crossing Rate (ZCR)**: Ratio of sign changes (0.0 to 1.0)\n3. **Spectral Flatness**: Measure of noise-like vs. tone-like (0.0 to 1.0)\n4. **Spectral Rolloff** (Hz): Frequency below which 85% of energy is concentrated\n5. **Decay Time** (ms): Time for signal to decay to -20dB\n\n**Rationale:** These features distinguish KICK (low centroid, high decay) from SNARE (mid centroid, high ZCR) from HI-HAT (high centroid, high flatness).\n\n---\n\n### FR-3: Sample Validation\n**Requirement:** The calibration procedure shall validate features before adding samples.\n\n**Validation Rules:**\n- Centroid: 0 Hz < centroid < Nyquist frequency (sample_rate / 2)\n- ZCR: 0.0 ≤ zcr ≤ 1.0\n- Flatness: 0.0 ≤ flatness ≤ 1.0\n- Rolloff: 0 Hz < rolloff < Nyquist frequency\n- Decay time: > 0 ms\n\n**Error Handling:**\n- Invalid samples rejected with error code and reason\n- Error logged for debugging\n- UI shows rejection feedback (optional)\n\n**Rationale:** Prevents corrupted data from affecting threshold computation.\n\n---\n\n### FR-4: Sample Collection Workflow\n**Requirement:** The calibration procedure shall collect 10 samples per sound type in sequence: KICK → SNARE → HI-HAT.\n\n**State Transitions:**\n1. **NotStarted** → **CollectingKick** (when `start_calibration()` called)\n2. **CollectingKick** → **CollectingSnare** (after 10 KICK samples)\n3. **CollectingSnare** → **CollectingHiHat** (after 10 SNARE samples)\n4. **CollectingHiHat** → **Complete** (after 10 HI-HAT samples)\n\n**Rationale:** Sequential collection provides clear user guidance and simplifies UI logic.\n\n---\n\n### FR-5: Progress Broadcasting\n**Requirement:** The calibration procedure shall broadcast progress updates via Tokio broadcast channel.\n\n**Progress Event Structure:**\n```rust\npub struct CalibrationProgress {\n    pub current_sound: String,      // \"KICK\" | \"SNARE\" | \"HIHAT\"\n    pub samples_collected: u8,      // 0-10\n    pub total_samples_needed: u8,   // Always 10\n}\n```\n\n**Broadcasting Rules:**\n- Broadcast after each valid sample added\n- Broadcast on state transition (e.g., KICK → SNARE)\n- Broadcast on error (optional)\n\n**Rationale:** Real-time UI updates improve user experience.\n\n---\n\n### FR-6: Threshold Computation\n**Requirement:** Upon completion, the system shall compute classification thresholds from collected samples.\n\n**Algorithm:**\n1. Calculate mean and standard deviation for each feature per sound type\n2. Compute decision boundaries using statistical thresholds\n3. Store thresholds in `CalibrationState`\n4. Serialize state to JSON for persistence\n\n**Rationale:** Thresholds enable accurate classification of future sounds.\n\n---\n\n### FR-7: Audio Engine Integration\n**Requirement:** The audio engine's analysis thread shall forward detected onsets to the calibration procedure during calibration mode.\n\n**Integration Points:**\n- Analysis thread checks if calibration is in progress\n- If active, calls `CalibrationProcedure::add_sample(features)`\n- If inactive, proceeds with normal classification\n\n**Rationale:** Connects onset detection to sample collection without duplicating DSP logic.\n\n## 5. Non-Functional Requirements\n\n### NFR-1: Performance\n**Requirement:** Calibration shall complete in < 2 minutes under normal usage.\n\n**Assumptions:**\n- User performs sounds at ~2 second intervals\n- 30 samples × 2 seconds = 60 seconds active time\n- + UI guidance + threshold computation < 60 seconds overhead\n- Total: ~120 seconds\n\n**Measurement:** End-to-end timer from `start_calibration()` to `finish_calibration()`\n\n---\n\n### NFR-2: Real-Time Latency\n**Requirement:** Progress updates shall reach the UI within 100ms of sample collection.\n\n**Components:**\n- Onset detection: < 50ms\n- Feature extraction: < 20ms\n- Progress broadcast: < 10ms\n- Dart stream processing: < 20ms\n\n**Measurement:** Timestamp comparison between onset detection and UI update logs\n\n---\n\n### NFR-3: Reliability\n**Requirement:** The calibration workflow shall handle errors gracefully without crashing.\n\n**Error Scenarios:**\n- Invalid features → Reject sample, log error, continue\n- Audio engine failure → Return `CalibrationError::AudioEngineError`\n- Broadcast channel failure → Log warning, continue (degraded mode)\n- Lock poisoning → Return `CalibrationError::StatePoisoned`\n\n**Rationale:** Production apps must not crash on edge cases.\n\n---\n\n### NFR-4: Testability\n**Requirement:** All calibration logic shall be unit testable with ≥ 90% coverage.\n\n**Architecture Requirements:**\n- Dependency injection for audio engine, broadcast channels\n- Mock calibration procedure for testing UI integration\n- Synthetic audio samples for testing onset detection\n- Deterministic feature vectors for testing validation logic\n\n**Rationale:** High test coverage prevents regressions and enables confident refactoring.\n\n---\n\n### NFR-5: Code Quality\n**Requirement:** Implementation shall follow SOLID principles and project guidelines.\n\n**Guidelines (from CLAUDE.md):**\n- Max 500 lines/file\n- Max 50 lines/function\n- Single Responsibility Principle\n- Dependency Injection\n- Structured error handling with error codes\n\n**Rationale:** Maintainable code reduces long-term costs.\n\n## 6. Out of Scope\n\nThe following are explicitly **NOT** included in this specification:\n\n1. **Advanced UI Features:**\n   - Visual waveform display during calibration\n   - Audio playback of collected samples\n   - Calibration history/analytics\n\n2. **Adaptive Calibration:**\n   - Automatic recalibration based on drift detection\n   - Continuous learning from user corrections\n\n3. **Multi-User Calibration:**\n   - Saving multiple calibration profiles per device\n   - Cloud sync of calibration data\n\n4. **Advanced DSP:**\n   - Machine learning-based classification (current spec uses rule-based thresholds)\n   - Spectral harmonics analysis\n\n**Rationale:** These features can be added in future specs after core calibration is stable.\n\n## 7. Assumptions and Constraints\n\n### Assumptions:\n1. User has granted microphone permissions before starting calibration\n2. Audio environment is reasonably quiet (< 40dB ambient noise)\n3. User understands basic beatbox sounds (KICK, SNARE, HI-HAT)\n4. Device supports low-latency audio via Oboe (Android 4.1+)\n\n### Constraints:\n1. **Platform:** Android-only (Oboe library constraint)\n2. **Sample Rate:** 48000 Hz (Oboe default)\n3. **Buffer Size:** Variable (Oboe auto-tuning)\n4. **Real-Time Safety:** No allocations, locks, or blocking in audio callback\n5. **Memory:** Limited by Android device (typically 2-4 GB available to app)\n\n## 8. Success Metrics\n\nThe calibration workflow implementation shall be considered successful if:\n\n1. **Functional Completeness:**\n   - ✓ All user stories pass acceptance criteria\n   - ✓ All functional requirements implemented\n   - ✓ End-to-end calibration completes without errors\n\n2. **Performance:**\n   - ✓ Calibration time < 2 minutes (measured via device logs)\n   - ✓ Progress latency < 100ms (measured via timestamps)\n   - ✓ No audio dropouts or glitches during calibration\n\n3. **Quality:**\n   - ✓ Unit test coverage ≥ 90%\n   - ✓ Integration tests pass for onset → progress flow\n   - ✓ Zero crashes in calibration workflow (tested over 100 runs)\n   - ✓ Code review passes (SOLID principles, < 500 lines/file)\n\n4. **User Experience:**\n   - ✓ Clear progress feedback visible in UI\n   - ✓ Smooth transition between sound types\n   - ✓ Completion message confirms successful calibration\n   - ✓ Saved calibration persists across app restarts\n\n## 9. Dependencies\n\n### Internal Dependencies:\n- `rust/src/audio/engine.rs` - Oboe audio streams, onset detection\n- `rust/src/analysis/mod.rs` - Spectral feature extraction\n- `rust/src/calibration/procedure.rs` - Sample collection logic\n- `rust/src/calibration/manager.rs` - Calibration lifecycle management\n- `rust/src/context.rs` - Dependency injection container\n- `rust/src/managers/broadcast.rs` - Progress broadcasting\n\n### External Dependencies:\n- `oboe-rs 0.6.1` - Audio I/O\n- `tokio 1.42.0` - Async runtime, broadcast channels\n- `flutter_rust_bridge 2.11.1` - FFI bridge\n- `serde_json` - Calibration state serialization\n\n### Test Dependencies:\n- `mockall` or manual mocks - Dependency injection for tests\n- Synthetic audio samples - Testing onset detection\n- Known feature vectors - Testing validation logic\n\n## 10. References\n\n- **Product Vision:** `.spec-workflow/steering/product.md`\n- **Technical Architecture:** `.spec-workflow/steering/tech.md`\n- **Codebase Structure:** `.spec-workflow/steering/structure.md`\n- **Existing Calibration Code:** `rust/src/calibration/`\n- **Audio Engine:** `rust/src/audio/engine.rs`\n- **FFI API:** `rust/src/api.rs`\n",
  "fileStats": {
    "size": 13800,
    "lines": 373,
    "lastModified": "2025-11-14T12:41:59.912Z"
  },
  "comments": []
}