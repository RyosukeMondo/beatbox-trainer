{
  "id": "snapshot_1763017526283_hstaf1f1y",
  "approvalId": "approval_1763017449265_plrxdppjc",
  "approvalTitle": "Android Build Integration - Design",
  "version": 2,
  "timestamp": "2025-11-13T07:05:26.283Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Android Build Integration\n\n## Overview\n\nThis design establishes the complete Android build infrastructure for the beatbox trainer application, addressing critical compilation failures that prevent the Rust audio engine from building for Android targets. The solution integrates cargo-ndk into the Flutter build pipeline, fixes Android-specific API incompatibilities in the audio callback and JNI initialization code, and ensures the native library (libbeatbox_trainer.so) is correctly packaged and loaded at runtime.\n\nThe implementation maintains the existing 4-layer native-first architecture (C++ Oboe → Rust → Java/JNI → Dart/Flutter) while adding the necessary platform-specific adaptations to make it functional on Android hardware.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **Native-First Architecture Preservation**: Maintains the 4-layer stack without introducing high-level audio plugins\n- **Real-Time Safety**: All fixes preserve lock-free, allocation-free audio callback guarantees\n- **Cross-Compilation**: Uses cargo-ndk (documented as required tool) with NDK r25c+ for ARM/ARM64 targets\n- **JNI Integration**: Implements the documented \"Manual JNI_OnLoad\" pattern required for Flutter+Oboe apps\n- **Performance Targets**: No regression - maintains < 20ms audio latency goal\n\n### Project Structure (structure.md)\n\n- **Android Isolation**: All Android-specific code confined to `android/` directory and conditional compilation blocks\n- **Build Configuration**: Gradle integration follows existing `android/app/build.gradle.kts` structure\n- **Module Boundaries**: Audio layer (Rust) remains independent of UI layer (Dart) per documented separation\n- **Documentation Standards**: Inline comments explain Android-specific JNI/NDK requirements\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **Error Handling (`rust/src/error.rs`)**: Extend `AudioError` enum with Android-specific errors (`JniInitFailed`, `ContextNotInitialized`)\n- **Build Scripts (`rust/build.rs`)**: Add Android target detection logic to existing build script\n- **MainActivity (`android/app/src/main/kotlin/MainActivity.kt`)**: Extend existing `init` block to load native library\n\n### Integration Points\n\n- **Flutter Build System**: Hook into existing `flutter build apk` via Gradle task dependencies\n- **Oboe Library (`oboe-rs`)**: Fix callback trait implementation to satisfy v0.6.x API changes\n- **ndk-context Initialization**: Integrate with existing `lib.rs` JNI_OnLoad infrastructure\n\n## Architecture\n\n### Build Pipeline Architecture\n\n```mermaid\ngraph TD\n    A[flutter build apk] --> B[Gradle assembleDebug]\n    B --> C[Custom Gradle Task: buildRustAndroid]\n    C --> D[cargo ndk -t arm64-v8a]\n    C --> E[cargo ndk -t armeabi-v7a]\n    C --> F[cargo ndk -t x86_64]\n    D --> G[Copy .so to jniLibs/arm64-v8a/]\n    E --> H[Copy .so to jniLibs/armeabi-v7a/]\n    F --> I[Copy .so to jniLibs/x86_64/]\n    G & H & I --> J[Gradle packages APK]\n    J --> K[APK contains libbeatbox_trainer.so]\n```\n\n### Runtime Initialization Flow\n\n```mermaid\nsequenceDiagram\n    participant App as Android App Launch\n    participant Main as MainActivity.kt\n    participant JNI as JNI_OnLoad (Rust)\n    participant NDK as ndk_context\n    participant Oboe as Oboe Audio Engine\n\n    App->>Main: onCreate()\n    Main->>Main: System.loadLibrary(\"beatbox_trainer\")\n    Main->>JNI: JNI_OnLoad(vm, context)\n    JNI->>NDK: initialize_android_context(vm, context)\n    NDK-->>JNI: Context initialized\n    JNI-->>Main: Library loaded\n    Main->>App: UI ready\n    App->>Oboe: user taps \"Start\"\n    Oboe->>Oboe: AudioStreamBuilder.open_stream()\n    Oboe-->>App: Audio running\n```\n\n### Modular Design Principles\n\n- **Conditional Compilation**: Use `#[cfg(target_os = \"android\")]` to isolate Android-specific code, keeping non-Android builds clean\n- **Build Script Modularity**: Separate cargo-ndk invocation logic into reusable Gradle task (can be shared across future Rust modules)\n- **Error Propagation**: Android initialization errors flow through existing `Result<T, AudioError>` pattern\n- **Platform Detection**: Rust `build.rs` detects Android target and configures oboe feature flags appropriately\n\n## Components and Interfaces\n\n### Component 1: Gradle Rust Build Task\n\n**File**: `android/app/build.gradle.kts`\n\n- **Purpose:** Automate cargo-ndk cross-compilation during Flutter build process\n- **Interfaces:**\n  ```kotlin\n  task(\"buildRustAndroid\") {\n      doLast {\n          // Execute cargo ndk for each architecture\n          exec { commandLine(\"cargo\", \"ndk\", ...) }\n          // Copy .so files to jniLibs\n      }\n  }\n  ```\n- **Dependencies:**\n  - Requires `cargo-ndk` installed on build machine\n  - Depends on Gradle `preBuild` task\n- **Reuses:** Existing `android.defaultConfig` for architecture list\n\n### Component 2: Fixed Oboe Audio Callback\n\n**File**: `rust/src/audio/engine.rs`\n\n- **Purpose:** Implement audio output callback compatible with oboe-rs v0.6.x `AudioOutputCallback` trait\n- **Interfaces:**\n  ```rust\n  struct OutputCallback {\n      frame_counter: Arc<AtomicU64>,\n      bpm: Arc<AtomicU32>,\n      // ... existing fields\n  }\n\n  impl AudioOutputCallback for OutputCallback {\n      type FrameType = (f32, oboe::Mono);\n\n      fn on_audio_ready(\n          &mut self,\n          _stream: &mut dyn AudioOutputStreamSafe,\n          frames: &mut [f32]\n      ) -> DataCallbackResult {\n          // Existing metronome logic\n      }\n  }\n  ```\n- **Dependencies:** `oboe::AudioOutputCallback`, `oboe::DataCallbackResult`\n- **Reuses:** Existing metronome generation logic from `audio/metronome.rs`\n\n### Component 3: ndk-context Initialization\n\n**File**: `rust/src/lib.rs`\n\n- **Purpose:** Initialize Android context when JNI_OnLoad is called\n- **Interfaces:**\n  ```rust\n  #[cfg(target_os = \"android\")]\n  #[no_mangle]\n  pub extern \"C\" fn JNI_OnLoad(vm: jni::JavaVM, _reserved: *mut std::os::raw::c_void) -> jni::sys::jint {\n      // Get application context from JavaVM\n      let env = vm.get_env().unwrap();\n      let ctx = env.call_static_method(...);\n\n      // Initialize ndk_context with both parameters\n      unsafe {\n          ndk_context::initialize_android_context(\n              vm.get_java_vm_pointer() as *mut _,\n              ctx.l().unwrap().into_raw() as *mut _\n          );\n      }\n      jni::sys::JNI_VERSION_1_6\n  }\n  ```\n- **Dependencies:** `jni` crate, `ndk-context` crate\n- **Reuses:** None (new Android-specific initialization)\n\n### Component 4: MainActivity Library Loading\n\n**File**: `android/app/src/main/kotlin/MainActivity.kt`\n\n- **Purpose:** Load native library and provide application context to JNI layer\n- **Interfaces:**\n  ```kotlin\n  class MainActivity: FlutterActivity() {\n      companion object {\n          init {\n              System.loadLibrary(\"beatbox_trainer\")\n          }\n      }\n  }\n  ```\n- **Dependencies:** Android SDK, Kotlin stdlib\n- **Reuses:** Existing FlutterActivity base class\n\n### Component 5: Android-Specific Error Types\n\n**File**: `rust/src/error.rs`\n\n- **Purpose:** Extend error handling to cover Android initialization failures\n- **Interfaces:**\n  ```rust\n  #[derive(Debug, Clone, PartialEq)]\n  pub enum AudioError {\n      // ... existing variants\n      JniInitFailed { reason: String },\n      ContextNotInitialized,\n  }\n\n  impl ErrorCode for AudioError {\n      fn code(&self) -> i32 {\n          match self {\n              // ... existing codes 1001-1007\n              AudioError::JniInitFailed { .. } => 1008,\n              AudioError::ContextNotInitialized => 1009,\n          }\n      }\n  }\n  ```\n- **Dependencies:** Existing `ErrorCode` trait\n- **Reuses:** Existing error handling infrastructure from `rust/src/error.rs`\n\n## Data Models\n\n### Build Configuration Model\n\n**File**: `android/app/build.gradle.kts`\n\n```kotlin\nandroid {\n    defaultConfig {\n        ndk {\n            abiFilters += listOf(\"arm64-v8a\", \"armeabi-v7a\", \"x86_64\")\n        }\n    }\n}\n\n// Custom properties for Rust build\nval rustTargets = mapOf(\n    \"arm64-v8a\" to \"aarch64-linux-android\",\n    \"armeabi-v7a\" to \"armv7-linux-androideabi\",\n    \"x86_64\" to \"x86_64-linux-android\"\n)\n```\n\n### JNI Context Model\n\n**File**: `rust/src/lib.rs`\n\n```rust\n#[cfg(target_os = \"android\")]\nstatic ANDROID_CONTEXT_INITIALIZED: AtomicBool = AtomicBool::new(false);\n\n// Tracks whether Android context was successfully initialized\n// Used to provide better error messages if audio engine starts before init\n```\n\n## Error Handling\n\n### Error Scenario 1: cargo-ndk Not Installed\n\n- **Handling:** Gradle task `buildRustAndroid` checks for `cargo-ndk` binary, fails with clear error message if missing\n- **User Impact:** Developer sees: \"cargo-ndk not found. Install with: cargo install cargo-ndk\"\n- **Recovery:** User installs cargo-ndk and retries build\n\n### Error Scenario 2: JNI Context Initialization Fails\n\n- **Handling:** `JNI_OnLoad` logs error to logcat and returns `JNI_VERSION_1_6` (Android continues but audio will fail later with `AudioError::ContextNotInitialized`)\n- **User Impact:** App launches but crashes when user taps \"Start\" button, with error dialog: \"Audio engine initialization failed (code 1009)\"\n- **Recovery:** Check device compatibility (requires Android 7.0+), check logcat for detailed JNI error\n\n### Error Scenario 3: Native Library Missing from APK\n\n- **Handling:** `System.loadLibrary()` throws `UnsatisfiedLinkError`, caught by Flutter error boundary\n- **User Impact:** App shows error screen: \"Native library not found. Please reinstall the app.\"\n- **Recovery:** Developer checks `unzip -l app-debug.apk` to verify .so files present, ensures build completed successfully\n\n### Error Scenario 4: Oboe Callback Trait Mismatch\n\n- **Handling:** Compilation fails with clear error message pointing to `engine.rs:153` callback definition\n- **User Impact:** Developer sees compiler error with trait bound requirements\n- **Recovery:** Follow compiler suggestion to implement `AudioOutputCallback` trait correctly\n\n### Error Scenario 5: Architecture Mismatch\n\n- **Handling:** Android Package Manager logs warning \"Unable to load native library for ABI\", falls back to alternative architecture if available\n- **User Impact:** None if APK contains multiple architectures; app runs on fallback ABI (armeabi-v7a on ARM64 device)\n- **Recovery:** Ensure all required architectures are built and packaged\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Rust Build Script Test**: Add `#[test]` in `build.rs` to verify Android target detection logic\n- **Error Code Test**: Extend `rust/src/error.rs` tests to cover new Android error variants (1008, 1009)\n- **JNI Initialization Mock**: Create test harness that simulates `JNI_OnLoad` call with mock JavaVM\n\n### Integration Testing\n\n- **Gradle Task Test**: Run `./gradlew buildRustAndroid` standalone to verify cargo-ndk invocation and .so file copying\n- **APK Packaging Test**: Use `unzip -l build/app/outputs/flutter-apk/app-debug.apk | grep libbeatbox_trainer.so` to verify all architectures present\n- **Library Loading Test**: Create minimal Android test app that calls `System.loadLibrary(\"beatbox_trainer\")` and verifies no `UnsatisfiedLinkError`\n\n### End-to-End Testing\n\n- **Physical Device Test (Pixel 9a)**:\n  1. Connect device via USB with debugging enabled\n  2. Run `flutter run -d 4C041JEBF15065`\n  3. Verify app launches without crashes\n  4. Tap \"Start\" button\n  5. Verify no `ContextNotInitialized` error\n  6. Verify audio callback begins executing (check logcat for metronome timing logs)\n\n- **Emulator Test (x86_64)**:\n  1. Launch Android emulator (API 30+)\n  2. Run `flutter run -d emulator-5554`\n  3. Verify app launches and x86_64 .so is loaded\n  4. Verify audio permissions granted\n  5. Verify audio engine starts successfully\n\n- **Build Reproducibility Test**:\n  1. Clean build: `flutter clean && flutter build apk`\n  2. Incremental build: Touch `rust/src/api.rs`, run `flutter build apk`\n  3. Verify Rust recompilation triggered and .so updated in APK\n  4. Verify build time < 30 seconds for incremental rebuild\n\n### Performance Testing\n\n- **Audio Latency Measurement**:\n  1. Connect audio loopback cable (microphone output → speaker input)\n  2. Start app and metronome\n  3. Record latency using external audio analysis tool\n  4. Verify < 20ms round-trip latency maintained after Android integration\n\n- **Build Time Benchmark**:\n  1. Full clean build: `time flutter clean && time flutter build apk`\n  2. Verify total time < 5 minutes\n  3. Rust-only change: `touch rust/src/audio/engine.rs && time flutter build apk`\n  4. Verify incremental build < 30 seconds\n",
  "fileStats": {
    "size": 12572,
    "lines": 326,
    "lastModified": "2025-11-13T07:03:54.740Z"
  },
  "comments": []
}