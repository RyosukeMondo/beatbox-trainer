#!/usr/bin/env bash
# Pre-commit hook for beatbox-trainer project
# Enforces code quality standards before allowing commits
#
# Installation:
#   cp scripts/pre-commit .git/hooks/pre-commit
#   chmod +x .git/hooks/pre-commit

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
MAX_FILE_LINES=500
MAX_FUNCTION_LINES=50
TIMEOUT=60
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
ARTIFACT_DIR="$PROJECT_ROOT/logs/smoke"
CLI_SMOKE_LOG="$ARTIFACT_DIR/cli_smoke.log"
HTTP_SMOKE_LOG="$ARTIFACT_DIR/http_smoke.log"
CLI_SMOKE_REPORT="$ARTIFACT_DIR/classify_basic_hits.json"
DIAG_RECORD_REPORT="$ARTIFACT_DIR/bbt_diag_record.json"
# Generated/third-party files that are exempt from line-count limits
GENERATED_FILE_PATTERNS=(
    "lib/bridge/api.dart/frb_generated.dart"
    "lib/bridge/api.dart/frb_generated.io.dart"
    "lib/bridge/api.dart/frb_generated.web.dart"
    "lib/bridge/api.dart/api.dart"
    "rust/src/bridge_generated.rs"
)

# Track overall status
FAILED=0

# Helper functions
print_header() {
    echo -e "\n${BLUE}===${NC} $1 ${BLUE}===${NC}"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
    FAILED=1
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check for required tools
check_prerequisites() {
    print_header "Checking prerequisites"

    local missing_tools=()

    if ! command_exists flutter; then
        missing_tools+=("flutter")
    fi

    if ! command_exists cargo; then
        missing_tools+=("cargo")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        echo "Please install the missing tools and try again."
        return 1
    fi

    print_success "All required tools available"
    return 0
}

# Check file sizes
check_file_sizes() {
    print_header "Checking file sizes (max ${MAX_FILE_LINES} lines)"

    local oversized_files=()

    # Check Dart files
    while IFS= read -r file; do
        if [ -f "$file" ]; then
            if should_skip_generated_file "$file"; then
                continue
            fi
            local line_count=$(wc -l < "$file")
            if [ "$line_count" -gt "$MAX_FILE_LINES" ]; then
                oversized_files+=("$file ($line_count lines)")
            fi
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(dart)$' || true)

    # Check Rust files (excluding test modules)
    while IFS= read -r file; do
        if [ -f "$file" ] && [[ ! "$file" =~ /tests?/ ]] && [[ ! "$file" =~ _test\.rs$ ]]; then
            if should_skip_generated_file "$file"; then
                continue
            fi
            local line_count=$(wc -l < "$file")
            if [ "$line_count" -gt "$MAX_FILE_LINES" ]; then
                oversized_files+=("$file ($line_count lines)")
            fi
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(rs)$' || true)

    if [ ${#oversized_files[@]} -ne 0 ]; then
        print_error "Files exceed ${MAX_FILE_LINES} line limit:"
        for file in "${oversized_files[@]}"; do
            echo "  - $file"
        done
        echo "Consider splitting these files into smaller modules."
        return 1
    fi

    print_success "All files within size limit"
    return 0
}

# Determine if a file should be skipped for generated-code checks
should_skip_generated_file() {
    local file="$1"
    for pattern in "${GENERATED_FILE_PATTERNS[@]}"; do
        if [[ -n "$pattern" && "$file" == $pattern ]]; then
            return 0
        fi
    done
    return 1
}

filter_generated_matches() {
    local lines="$1"
    local filtered=()
    while IFS= read -r line; do
        if [ -z "$line" ]; then
            continue
        fi
        local skip=0
        for pattern in "${GENERATED_FILE_PATTERNS[@]}"; do
            local abs_path="$PROJECT_ROOT/$pattern"
            if [[ -n "$pattern" && "$line" == "$abs_path"* ]]; then
                skip=1
                break
            fi
        done
        if [ $skip -eq 0 ]; then
            filtered+=("$line")
        fi
    done <<< "$lines"

    if [ ${#filtered[@]} -ne 0 ]; then
        printf '%s\n' "${filtered[@]}"
    fi
}

# Check function sizes in Dart files
check_dart_function_sizes() {
    print_header "Checking Dart function sizes (max ${MAX_FUNCTION_LINES} lines)"

    local oversized_functions=()

    while IFS= read -r file; do
        if [ -f "$file" ]; then
            # Simple pattern: look for function/method declarations and count lines until closing brace
            # This is a basic heuristic and may not catch all cases perfectly
            local in_function=0
            local function_name=""
            local function_start=0
            local brace_count=0
            local line_num=0

            while IFS= read -r line; do
                ((line_num++))

                # Detect function start (simplified pattern)
                if [[ "$line" =~ (void|Future|Stream|Widget|int|double|bool|String|var|dynamic|[A-Z][a-zA-Z0-9]*)[[:space:]]+([_a-zA-Z][_a-zA-Z0-9]*)[[:space:]]*\( ]]; then
                    if [ $in_function -eq 0 ]; then
                        function_name="${BASH_REMATCH[2]}"
                        function_start=$line_num
                        in_function=1
                        brace_count=0
                    fi
                fi

                # Count braces
                if [ $in_function -eq 1 ]; then
                    local open_braces=$(echo "$line" | tr -cd '{' | wc -c)
                    local close_braces=$(echo "$line" | tr -cd '}' | wc -c)
                    brace_count=$((brace_count + open_braces - close_braces))

                    # Function ended
                    if [ $brace_count -le 0 ] && [ $open_braces -gt 0 -o $close_braces -gt 0 ]; then
                        local function_length=$((line_num - function_start + 1))
                        if [ $function_length -gt $MAX_FUNCTION_LINES ]; then
                            oversized_functions+=("$file:$function_start: $function_name() is $function_length lines")
                        fi
                        in_function=0
                    fi
                fi
            done < "$file"
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(dart)$' || true)

    if [ ${#oversized_functions[@]} -ne 0 ]; then
        print_warning "Functions exceed ${MAX_FUNCTION_LINES} line guideline:"
        for func in "${oversized_functions[@]}"; do
            echo "  - $func"
        done
        echo "Consider breaking down these functions into smaller helpers."
        # Don't fail on this, just warn
    else
        print_success "All Dart functions within size guideline"
    fi

    return 0
}

# Check Rust function sizes
check_rust_function_sizes() {
    print_header "Checking Rust function sizes (max ${MAX_FUNCTION_LINES} lines)"

    local oversized_functions=()

    while IFS= read -r file; do
        if [ -f "$file" ]; then
            # Use basic pattern matching for Rust functions
            local in_function=0
            local function_name=""
            local function_start=0
            local brace_count=0
            local line_num=0

            while IFS= read -r line; do
                ((line_num++))

                # Detect function start (pub fn, fn, async fn, etc.)
                if [[ "$line" =~ (pub[[:space:]]+)?(async[[:space:]]+)?fn[[:space:]]+([_a-zA-Z][_a-zA-Z0-9]*) ]]; then
                    if [ $in_function -eq 0 ]; then
                        function_name="${BASH_REMATCH[3]}"
                        function_start=$line_num
                        in_function=1
                        brace_count=0
                    fi
                fi

                # Count braces
                if [ $in_function -eq 1 ]; then
                    local open_braces=$(echo "$line" | tr -cd '{' | wc -c)
                    local close_braces=$(echo "$line" | tr -cd '}' | wc -c)
                    brace_count=$((brace_count + open_braces - close_braces))

                    # Function ended
                    if [ $brace_count -le 0 ] && [ $close_braces -gt 0 ]; then
                        local function_length=$((line_num - function_start + 1))
                        if [ $function_length -gt $MAX_FUNCTION_LINES ]; then
                            oversized_functions+=("$file:$function_start: fn $function_name() is $function_length lines")
                        fi
                        in_function=0
                    fi
                fi
            done < "$file"
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(rs)$' || true)

    if [ ${#oversized_functions[@]} -ne 0 ]; then
        print_warning "Rust functions exceed ${MAX_FUNCTION_LINES} line guideline:"
        for func in "${oversized_functions[@]}"; do
            echo "  - $func"
        done
        echo "Consider extracting helper methods from these functions."
        # Don't fail on this, just warn
    else
        print_success "All Rust functions within size guideline"
    fi

    return 0
}

# Run Dart formatting check
check_dart_format() {
    print_header "Checking Dart formatting"

    # Get staged Dart files
    local dart_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(dart)$' || true)

    if [ -z "$dart_files" ]; then
        print_success "No Dart files to format"
        return 0
    fi

    local filtered_files=()
    while IFS= read -r file; do
        if [ -z "$file" ]; then
            continue
        fi
        if should_skip_generated_file "$file"; then
            continue
        fi
        filtered_files+=("$file")
    done <<< "$dart_files"

    if [ ${#filtered_files[@]} -eq 0 ]; then
        print_success "No Dart files to format"
        return 0
    fi

    # Run dart format in check mode
    if dart format --set-exit-if-changed --output=none "${filtered_files[@]}" >/dev/null 2>&1; then
        print_success "Dart code is properly formatted"
        return 0
    else
        print_error "Dart code is not properly formatted"
        echo "Run 'dart format .' to fix formatting issues."
        return 1
    fi
}

# Run Flutter analyzer
check_flutter_analyze() {
    print_header "Running Flutter analyzer"

    if flutter analyze --no-pub >/tmp/flutter_analyze.log 2>&1; then
        print_success "Flutter analyzer passed"
        return 0
    else
        print_error "Flutter analyzer found issues"
        cat /tmp/flutter_analyze.log
        echo "Fix the issues reported by 'flutter analyze' before committing."
        return 1
    fi
}

# Run Rust formatting check
check_rust_format() {
    print_header "Checking Rust formatting"

    # Get staged Rust files
    local rust_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(rs)$' || true)

    if [ -z "$rust_files" ]; then
        print_success "No Rust files to format"
        return 0
    fi

    cd rust
    if cargo fmt -- --check >/dev/null 2>&1; then
        print_success "Rust code is properly formatted"
        cd ..
        return 0
    else
        print_error "Rust code is not properly formatted"
        cd ..
        echo "Run 'cd rust && cargo fmt' to fix formatting issues."
        return 1
    fi
}

# Run Clippy
check_clippy() {
    print_header "Running Clippy (Rust linter)"

    # Get staged Rust files
    local rust_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(rs)$' || true)

    if [ -z "$rust_files" ]; then
        print_success "No Rust files to lint"
        return 0
    fi

    cd rust
    if cargo clippy --all-targets -- -D warnings >/tmp/clippy.log 2>&1; then
        print_success "Clippy checks passed"
        cd ..
        return 0
    else
        print_error "Clippy found issues"
        cd ..
        cat /tmp/clippy.log
        echo "Fix the issues reported by clippy before committing."
        return 1
    fi
}

# Run tests
run_tests() {
    print_header "Running tests"

    local has_dart_changes=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(dart)$' || true)
    local has_rust_changes=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(rs)$' || true)
    local flutter_test_args=()

    # Default: skip slow-tagged tests for faster local commits.
    # Opt-in to full suite with INCLUDE_SLOW_TESTS=1.
    if [ "${INCLUDE_SLOW_TESTS:-0}" -ne 1 ]; then
        flutter_test_args+=(--exclude-tags=slow)
    fi
    # Avoid implicit pub fetch on every commit; callers can override via env.
    flutter_test_args+=(--no-pub)

    local test_failed=0

    # Run Dart tests if there are Dart changes
    if [ -n "$has_dart_changes" ]; then
        if [ "${SKIP_FLUTTER_TESTS:-0}" -eq 1 ]; then
            print_warning "SKIP_FLUTTER_TESTS=1 set; skipping Flutter tests"
        else
            echo "Running Flutter tests..."
            if flutter test "${flutter_test_args[@]}" >/tmp/flutter_test.log 2>&1; then
                print_success "Flutter tests passed"
            else
                print_error "Flutter tests failed"
                cat /tmp/flutter_test.log
                test_failed=1
            fi
        fi
    else
        print_success "No Dart changes, skipping Flutter tests"
    fi

    # Run Rust tests if there are Rust changes
    if [ -n "$has_rust_changes" ]; then
        echo "Running Rust tests..."
        cd rust
        if cargo test >/tmp/cargo_test.log 2>&1; then
            print_success "Rust tests passed"
            cd ..
        else
            print_error "Rust tests failed"
            cd ..
            cat /tmp/cargo_test.log
            test_failed=1
        fi
    else
        print_success "No Rust changes, skipping Rust tests"
    fi

    if [ $test_failed -eq 1 ]; then
        return 1
    fi

    return 0
}

run_cli_smoke_tests() {
    print_header "Running CLI fixture harness smoke tests"

    if [ "${SKIP_CLI_SMOKE_TESTS:-0}" -eq 1 ]; then
        print_warning "SKIP_CLI_SMOKE_TESTS=1 set; skipping CLI smoke tests"
        return 0
    fi

    if [ ! -f "$PROJECT_ROOT/rust/src/bin/beatbox_cli.rs" ]; then
        print_warning "beatbox_cli binary not found; skipping CLI harness smoke tests"
        return 0
    fi

    mkdir -p "$ARTIFACT_DIR"
    : > "$CLI_SMOKE_LOG"
    echo "[CLI smoke] $(date -Iseconds)" >> "$CLI_SMOKE_LOG"

    local classify_cmd=(cargo run --bin beatbox_cli -- classify --fixture basic_hits --expect fixtures/basic_hits.expect.json --output "$CLI_SMOKE_REPORT")
    local stream_cmd=(cargo run --bin beatbox_cli -- stream --fixture basic_hits --bpm 110)
    local dump_cmd=(cargo run --bin beatbox_cli -- dump-fixtures)
    local diag_run_cmd=(cargo run --features diagnostics_fixtures --bin bbt-diag -- run --synthetic sine --watch-ms 300 --telemetry-format json)
    local diag_record_cmd=(cargo run --features diagnostics_fixtures --bin bbt-diag -- record --synthetic sine --watch-ms 300 --max-events 4 --output "$DIAG_RECORD_REPORT")

    if (
        cd "$PROJECT_ROOT/rust" &&
            timeout "$TIMEOUT" "${classify_cmd[@]}" </dev/null >>"$CLI_SMOKE_LOG" 2>&1 &&
            timeout "$TIMEOUT" "${stream_cmd[@]}" </dev/null >>"$CLI_SMOKE_LOG" 2>&1 &&
            timeout "$TIMEOUT" "${dump_cmd[@]}" </dev/null >>"$CLI_SMOKE_LOG" 2>&1 &&
            timeout "$TIMEOUT" "${diag_run_cmd[@]}" </dev/null >>"$CLI_SMOKE_LOG" 2>&1
            # timeout "$TIMEOUT" "${diag_record_cmd[@]}" </dev/null >>"$CLI_SMOKE_LOG" 2>&1
    ); then
        print_success "CLI harness smoke tests passed (logs: $CLI_SMOKE_LOG)"
        if [ -f "$CLI_SMOKE_REPORT" ]; then
            echo "Classification report stored at $CLI_SMOKE_REPORT"
        fi
        if [ -f "$DIAG_RECORD_REPORT" ]; then
            echo "Diagnostics record stored at $DIAG_RECORD_REPORT"
        fi
    else
        print_error "CLI harness smoke tests failed (see $CLI_SMOKE_LOG)"
        return 1
    fi
}

run_http_smoke_checks() {
    print_header "Running HTTP debug server smoke tests"
    mkdir -p "$ARTIFACT_DIR"
    : > "$HTTP_SMOKE_LOG"
    echo "[HTTP smoke] $(date -Iseconds)" >> "$HTTP_SMOKE_LOG"

    if (
        cd "$PROJECT_ROOT/rust" &&
            timeout "$TIMEOUT" cargo test --features debug_http http::routes::tests:: -- --nocapture </dev/null >>"$HTTP_SMOKE_LOG" 2>&1
    ); then
        print_success "HTTP smoke tests passed (logs: $HTTP_SMOKE_LOG)"
    else
        print_error "HTTP smoke tests failed (see $HTTP_SMOKE_LOG)"
        return 1
    fi
}

run_diagnostics_baseline_diff() {
    print_header "Checking diagnostics telemetry baselines"

    if [ "${SKIP_DIAGNOSTICS_BASELINE:-0}" -eq 1 ]; then
        print_warning "SKIP_DIAGNOSTICS_BASELINE=1 set; skipping diagnostics baseline diff"
        return 0
    fi

    local baseline_file="$PROJECT_ROOT/logs/smoke/baselines/default-smoke.json"
    if [ ! -f "$baseline_file" ]; then
        print_warning "No default-smoke baseline snapshot found; skipping diff"
        return 0
    fi

    local changed_files=$(git diff --cached --name-only --diff-filter=ACM || true)
    if [ -z "$changed_files" ]; then
        print_success "No staged files, skipping baseline diff"
        return 0
    fi

    local should_run=0
    while IFS= read -r file; do
        case "$file" in
            rust/src/*|rust/src/bin/*|tools/cli/diagnostics/*|lib/services/audio/*|lib/controllers/debug/*|scripts/pre-commit|logs/smoke/baselines/*)
                should_run=1
                break
                ;;
        esac
    done <<< "$changed_files"

    if [ $should_run -eq 0 ]; then
        print_success "No diagnostics-sensitive files changed"
        return 0
    fi

    if ! command_exists dart; then
        print_warning "dart command not found; skipping diagnostics baseline diff"
        return 0
    fi

    local baseline_log="$PROJECT_ROOT/logs/keynote-grade-testing/task_5.log"
    mkdir -p "$(dirname "$baseline_log")"

    if dart run tools/cli/diagnostics/lib/baseline_diff.dart \
        --project-root "$PROJECT_ROOT" \
        --scenario default-smoke \
        --baseline "$baseline_file" \
        --run-playbook \
        >"$baseline_log" 2>&1; then
        print_success "Diagnostics baseline matches (default-smoke)"
    else
        print_error "Diagnostics baseline drift detected (see $baseline_log)"
        tail -n 200 "$baseline_log"
        return 1
    fi
}

check_bridge_stubs() {
    print_header "Scanning bridge layers for TODO/FIXME stubs"
    local paths=(
        "$PROJECT_ROOT/lib/bridge"
        "$PROJECT_ROOT/lib/services/audio"
        "$PROJECT_ROOT/rust/src/api.rs"
    )
    local pattern='TODO|FIXME|UnimplementedError|unimplemented!|todo!'
    local findings=""

    for path in "${paths[@]}"; do
        if [ -e "$path" ]; then
            local result=""
            if command_exists rg; then
                result=$(rg --no-heading --line-number --color=never -e "$pattern" "$path" || true)
            else
                result=$(grep -RInE "$pattern" "$path" || true)
            fi
            result=$(filter_generated_matches "$result")
            if [ -n "$result" ]; then
                findings+=$'\n'"$result"
            fi
        fi
    done

    if [ -n "$findings" ]; then
        print_error "Stub markers detected in bridge layers:"
        echo "$findings"
        return 1
    else
        print_success "No stub markers found in bridge layers"
    fi
}

# Main execution
main() {
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}  Beatbox Trainer Pre-Commit Quality Gate${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    # Start timer
    local start_time=$(date +%s)

    # Check if there are any staged changes
    if ! git diff --cached --quiet; then
        :
    else
        print_warning "No staged changes to commit"
        exit 0
    fi

    # Run all checks
    check_prerequisites || exit 1
    check_file_sizes || true  # Continue even if this fails for now
    check_dart_function_sizes || true  # Warning only
    check_rust_function_sizes || true  # Warning only
    check_dart_format || true
    check_flutter_analyze || true
    check_rust_format || true
    check_clippy || true
    run_tests || true
    run_cli_smoke_tests || true
    run_http_smoke_checks || true
    run_diagnostics_baseline_diff || true
    check_bridge_stubs || true

    # End timer
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    echo -e "\n${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    if [ $FAILED -eq 1 ]; then
        echo -e "${RED}✗ Pre-commit checks FAILED${NC} (${duration}s)"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo "Please fix the issues above before committing."
        echo "To bypass this hook (not recommended): git commit --no-verify"
        exit 1
    else
        echo -e "${GREEN}✓ All pre-commit checks PASSED${NC} (${duration}s)"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        exit 0
    fi
}

# Run main function
main "$@"
