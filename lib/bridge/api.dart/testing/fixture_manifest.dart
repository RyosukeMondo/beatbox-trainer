// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'fixture_manifest.freezed.dart';

/// Declarative BPM bounds enforced by diagnostics consumers.
class FixtureBpmRange {
  final int min;
  final int max;

  const FixtureBpmRange({required this.min, required this.max});

  @override
  int get hashCode => min.hashCode ^ max.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FixtureBpmRange &&
          runtimeType == other.runtimeType &&
          min == other.min &&
          max == other.max;
}

/// Rich metadata describing how a fixture should behave.
class FixtureManifestEntry {
  final String id;
  final String? description;
  final FixtureSourceDescriptor source;
  final int sampleRate;
  final int durationMs;
  final int loopCount;
  final int channels;
  final Map<String, String> metadata;
  final FixtureBpmRange bpm;
  final Map<String, int> expectedCounts;
  final List<String> anomalyTags;
  final FixtureToleranceEnvelope tolerances;

  const FixtureManifestEntry({
    required this.id,
    this.description,
    required this.source,
    required this.sampleRate,
    required this.durationMs,
    required this.loopCount,
    required this.channels,
    required this.metadata,
    required this.bpm,
    required this.expectedCounts,
    required this.anomalyTags,
    required this.tolerances,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      description.hashCode ^
      source.hashCode ^
      sampleRate.hashCode ^
      durationMs.hashCode ^
      loopCount.hashCode ^
      channels.hashCode ^
      metadata.hashCode ^
      bpm.hashCode ^
      expectedCounts.hashCode ^
      anomalyTags.hashCode ^
      tolerances.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FixtureManifestEntry &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          description == other.description &&
          source == other.source &&
          sampleRate == other.sampleRate &&
          durationMs == other.durationMs &&
          loopCount == other.loopCount &&
          channels == other.channels &&
          metadata == other.metadata &&
          bpm == other.bpm &&
          expectedCounts == other.expectedCounts &&
          anomalyTags == other.anomalyTags &&
          tolerances == other.tolerances;
}

@freezed
sealed class FixtureSourceDescriptor with _$FixtureSourceDescriptor {
  const FixtureSourceDescriptor._();

  const factory FixtureSourceDescriptor.wavFile({required String path}) =
      FixtureSourceDescriptor_WavFile;
  const factory FixtureSourceDescriptor.synthetic({
    required ManifestSyntheticPattern pattern,
    required double frequencyHz,
    required double amplitude,
  }) = FixtureSourceDescriptor_Synthetic;
  const factory FixtureSourceDescriptor.loopback({String? device}) =
      FixtureSourceDescriptor_Loopback;
}

/// Simple threshold descriptor with upper-bound semantics.
class FixtureThreshold {
  final double max;

  const FixtureThreshold({required this.max});

  @override
  int get hashCode => max.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FixtureThreshold &&
          runtimeType == other.runtimeType &&
          max == other.max;
}

/// Envelope describing the allowed drift for latency + classification accuracy.
class FixtureToleranceEnvelope {
  final FixtureThreshold latencyMs;
  final FixtureThreshold classificationDropPct;
  final FixtureThreshold bpmDeviationPct;

  const FixtureToleranceEnvelope({
    required this.latencyMs,
    required this.classificationDropPct,
    required this.bpmDeviationPct,
  });

  @override
  int get hashCode =>
      latencyMs.hashCode ^
      classificationDropPct.hashCode ^
      bpmDeviationPct.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FixtureToleranceEnvelope &&
          runtimeType == other.runtimeType &&
          latencyMs == other.latencyMs &&
          classificationDropPct == other.classificationDropPct &&
          bpmDeviationPct == other.bpmDeviationPct;
}

/// Mirror of [`SyntheticPattern`] for manifest-friendly serde.
enum ManifestSyntheticPattern { sine, square, whiteNoise, impulseTrain }
